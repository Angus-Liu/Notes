# 第 4 条：通过私有构造器强化不可实例化的能力

有时候，你想要编写一个只包含静态方法和静态属性的类。这些类有着不好的名声，因为有些人滥用它们以避免在对象的角度进行思考，但是它们确实有用。它们可用于以 java.lang.Math 或者 java.utill.Arrays 的方式把初始值或数组上的相关方法进行组合。它们还可用于以 java.util.Collections 的方式为实现某些接口的对象对静态方法（包括工厂（[第 1 条][item1]））进行组合（自 Java 8 开始，你也可以把这些方法放到接口中，假设那是你的修改）。最后，这些类可用于把 final 类上的方法进行组合，因为不能把它们放到子类中。

这样的实用工具类（utility class）不是为实例化而设计的，它的实例是没有意义的。 然而，当缺乏显示构造器时，编译器会提供一个公有的、无参数的默认构造器（default constructor）。对使用者而言，这个构造器和其它任何构造器都是没有区别的。在已发布的 API 中，无意中发现可实例化的类并不罕见。

**企图通过使一个类抽象来强制不可实例化是行不通的**。  该类可以被子类化，并且子类也可以实例化。此外，它会误导读者认为该类是为继承而设计的（[第 19 条][item19]）。然而，这有一个简单的习惯用法来确保不可实例化。只有当一个类不包含显示构造器时，才会生成一个默认的构造器。，所以**通过包含私有构造器，可以使类不可实例化**。

```java
// 不可实例化工具类
public class UtilityClass {
    //	禁止默认构造器以实现非实例化
    private UtilityClass() {
        throw new AssertionError();
    }
    // ..
    // 其余省略
}
```

因为显示构造器是私有的，所以在类外面是不可访问的。AssertionError 并不是严格需要的，但它提供了保险，以防止从类中意外的调用构造器。它保证类在任何环境下都绝不可能被实例化。这个习惯用法有点违反直觉，因为构造器是明确提供的，以便它无法被调用。因此。明智的做法就是包含一条注释，如前面所示。

作为副作用，这个习惯用法也阻止了类被实例化。所有的构造器必须显示或隐式的调用一个超类（superclass）构造器，在这种情况下，子类就没有可以访问的超类构造器来调用了。

[item1]:https://github.com/learning-and-thinking/Effective-Java-3rd-Edition-zh/blob/master/2.%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/%E7%AC%AC%201%20%E6%9D%A1%EF%BC%9A%E8%80%83%E8%99%91%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%99%A8.md
[item19]:url	"在未来填入第 19 条的 url，否则无法进行跳转"

---

> 翻译：Inno




