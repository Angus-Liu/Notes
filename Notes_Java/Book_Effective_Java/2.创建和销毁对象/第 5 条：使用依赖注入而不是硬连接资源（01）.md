## 第 5 条：使用依赖注入取代硬连接资源
​	很多类依赖于一个或多个基础资源。比如，一个拼写检查器（SpellChecker）依赖一个词典。一些类实现为静态工具类（[第 4 条](https://)）并不少见：

```JAVA
// 静态工具类的不恰当使用 - 不灵活 & 不可测试! 
public class SpellChecker { 

	private static final Lexicon dictionary = ...;

	private SpellChecker() {} // 不可实例化

	public static boolean isValid(String word) { ... }
	public static List<String> suggestions(String typo) { ... }
}

```

​	同样，有些类实现为单例也很常见：

```JAVA
// 单例的不恰当使用 - 不灵活 & 不可测试!

 public class SpellChecker { 

	private final Lexicon dictionary = ...;

	private SpellChecker(...) {} 

	public static INSTANCE = new SpellChecker(...);

	public boolean isValid(String word) { ... }

	public List<String> suggestions(String typo) { ... }

 }
```

​	 这两种方式很不尽人意，他们都假设永远只有一个字典被应用。事实上，每种语言都有他自己的字典，特殊词汇表会使用特殊的字典。同样，用一个特殊的字典来测试也是我们所期望的。妄想使用一个字典满足所有的需求只是一个理想而已。

​	你可能想到在 `SpellChecker` 中去掉 `dictionary` 的 `final` 属性然后添加一个方法来让 `SpellChecker` 支持多个字典，然而这是有缺陷的，更容易导致错误，而且在并发环境中不可运行。**静态工具类和单例不适合应用于其行为被底层资源参数化的类**。

​	按照需求我们得支持多个类的实例（在我们的例子中是 `SpellChcker` ），在每个实例中使用客户端所需要的资源（在我们例子中是 `dictionary` ）。**在实例化时把依赖资源加入到构造器中**是一个便捷的方法。这是依赖注入（*`dependency injection`*）的一种形式：字典是拼写检查器的依赖（*`dependency`*）在 `SpellChecker` 对象被创建时注入到其构造方法中。

```java
	// 依赖注入提供了良好的灵活性和可测性
	public class SpellChecker {
		private final Lexicon dictionary;
        
		public SpellChecker(Lexicon dictionary) {
		this.dictionary = Objects.requireNonNull(dictionary);
		}
        
        public boolean isValid(String word) { ... }
        public List<String> suggestions(String typo) { ... }
    }
```

​	依赖注入的方法很多程序员常年都在使用却不知道它还有个名字。虽然我们的拼写检查器的例子只有一个简单的资源（`dictionary`），实际上依赖注入可以支持任意数量的资源和依赖图。它保证了程序的重用性（[第 17 条](..)），所以多个客户端可以同时共享依赖对象（假如客户端申请同一个底层资源）。依赖注入同样适用于构造器，静态工厂和构建器（[第 2 条](...)）等。

​	还有一种便捷的用法是给构造器传递一个资源工厂（*`factory`*），即创建类型实例时可以被反复调用的对象。比如工厂方法模式（*`the Factory Method pattern`*）。JAVA 8 中引入的 `Supplier<T>` 接口就是一个典型的资源工厂。当一个方法使用 `Supplier<T>` 作为输入参数时，应该通过使用边界通配符（*`bound wildcard type`* [第 31 条](..)）限制其工厂的类型参数，这样客户端就可以传入一个工厂来创建指定类型的子类型。比如下面这个例子，使用客户端提供的工厂来让 `mosaic` 方法创建 `tile` 类型的变量：

```java
	Mosaic create(Supplier<? extends Tile> tileFactory) { ... }
```

​	依赖注入大大提高了程序的灵活性和可测性，但当包含过多的依赖时依然会使项目杂乱无章。使用一些依赖注入框架（*`dependency injection framework`*）可以处理这个问题，比如 [Dagger]( http://square.github.io/dagger/), [Guice](https://github.com/google/guice), [Spring](https://projects.spring.io/spring-framework/)等。本书不讨论这些框架的用法，注意：没必要使用框架来实现一些常规的依赖注入。

​	总而言之，不要使用单例或静态类来实现一些依赖于底层资源的类，也不要使用类直接创建这些资源。相反，把资源传递到构造器，或者让工厂来创建它们。依赖注入的使用会大大提高类的灵活性、可重用性和测试性。