## b吧第 6 条：避免创建不必要的对象

通常，应当重用一个对象，而不是在每次需要时就创建一个功能相同的新对象。重用方式既快速，也更流行。如果一个对象是不可变的（immutable [第 17 条][item17]），那它总是可以被重用。 

作为一个极端的反面例子，考虑下面的语句： 

```java
String s = new String("bikini");  // 千万不要这么做！
```

该语句在每次执行时都创建一个新的 String 实例，但是这些对象的创建都是不必要的。传递给 String 构造器的参数（“bikini”）本身就是一个 String 实例，功能上与构造器创建的所有对象相同。如果这种用法出现在循环或频繁调用的方法中，就会创建成千上百万个不必要的 String 实例。 

改进后的版本如下: 

```java
String s = "bikini";
```

这个版本只使用了一个 String 实例，而不是在每次执行时都创建一个新的。此外，它可以保证，对于所有在同一虚拟机中运行的代码，只要它们包含相同的字符串字面量 [JLS, 3.10.5]，该对象就会被重用。 

For example, the factory method `Boolean.valueOf(String)` is preferable to the constructor `Boolean(String)`, which was deprecated in Java 9. The constructor *must* create a new object each time it’s called, while the factory method is never required to do so and won’t in practice. In addition to reusing immutable objects, you can also reuse mutable objects if you know they won’t be modified.

对于同时提供了静态工厂方法（[第 1 条][item1]）和构造器的不可变类，通常可以使用静态工厂方法来避免创建不必要的对象。例如，工厂方法 `Boolean.valueOf(String)` 比构造器 `Boolean(String)` 更可取，后者在 Java 9 中被弃用。构造器必须每次调用一个新对象时都创建一个新对象，而工厂方法从来没有被要求这样做，实际上也不会。除了重用不可变对象之外，如果知道不会修改可变对象，还可以重用可变对象。 

Some object creations are much more expensive than others. If you’re going to need such an “expensive object” repeatedly, it may be advisable to cache it for reuse. Unfortunately, it’s not always obvious when you’re creating such an object. Suppose you want to write a method to determine whether a string is a valid Roman numeral. Here’s the easiest way to do this using a regular expression:

有些对象创建要比其他对象昂贵得多。如果您将反复需要这样一个“昂贵的对象”，那么最好将其缓存以供重用。不幸的是，在创建这样的对象时，并不总是显而易见的。假设您要编写一个方法来确定字符串是否是有效的罗马数字。下面是使用正则表达式进行此操作的最简单方法: 

```java
// Performance can be greatly improved!

static boolean isRomanNumeral(String s) {

    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"

            + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

}
```

The problem with this implementation is that it relies on the `String.matches` method. **While** `String.matches` **is the easiest way to check if a string matches a regular expression, it’s not suitable for repeated use in performance-critical situations.**The problem is that it internally creates a `Pattern` instance for the regular expression and uses it only once, after which it becomes eligible for garbage collection. Creating a `Pattern`instance is expensive because it requires compiling the regular expression into a finite state machine.

这个实现的问题是它依赖于字符串。匹配方法。当字符串。匹配是检查字符串是否与正则表达式匹配的最简单方法，它不适合在性能关键的情况下重复使用。问题是，它在内部为正则表达式创建一个模式实例，并且只使用它一次，之后它就可以进行垃圾收集了。创建一个模式实例非常昂贵，因为它需要将正则表达式编译成一个有限状态机。 

To improve the performance, explicitly compile the regular expression into a `Pattern`instance (which is immutable) as part of class initialization, cache it, and reuse the same instance for every invocation of the `isRomanNumeral` method:

为了提高性能，显式地将正则表达式编译为一个模式实例(它是不可变的)，作为类初始化的一部分，缓存它，并在每次调用isRomanNumeral方法时重用同一个实例: 

```java
// Reusing expensive object for improved performance

public class RomanNumerals {

    private static final Pattern ROMAN = Pattern.compile(

            "^(?=.)M*(C[MD]|D?C{0,3})"

            + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");



    static boolean isRomanNumeral(String s) {

        return ROMAN.matcher(s).matches();

    }

}
```

The improved version of `isRomanNumeral` provides significant performance gains if invoked frequently. On my machine, the original version takes 1.1 µs on an 8-character input string, while the improved version takes 0.17 µs, which is 6.5 times faster. Not only is the performance improved, but arguably, so is clarity. Making a static final field for the otherwise invisible `Pattern` instance allows us to give it a name, which is far more readable than the regular expression itself.

改进版的isRomanNumeral提供了显著的性能收益，如果经常调用。在我的机器上,原始版本1.1µs 8-character输入字符串,而改进的版本需要0.17µs快6.5倍。不仅性能得到了改善，而且清晰度也得到了提高。为不可见的模式实例创建静态final字段允许我们给它一个名称，这个名称要比正则表达式本身可读性强得多。 

If the class containing the improved version of the `isRomanNumeral` method is initialized but the method is never invoked, the field `ROMAN` will be initialized needlessly. It would be possible to eliminate the initialization by *lazily initializing* the field ([Item 83](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev83)) the first time the `isRomanNumeral` method is invoked, but this is *not* recommended. As is often the case with lazy initialization, it would complicate the implementation with no measurable performance improvement ([Item 67](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev67)).

如果初始化了包含改进版本的isromaneral方法的类，但从未调用该方法，则将不必要地初始化字段ROMAN。第一次调用isromaneral方法时，可以通过延迟初始化字段(第83项)来消除初始化，但不建议这样做。与延迟初始化的情况一样，延迟初始化会使实现复杂化，并且不会带来可度量的性能改进(项目67)。 

When an object is immutable, it is obvious it can be reused safely, but there are other situations where it is far less obvious, even counterintuitive. Consider the case of *adapters*[[Gamma95](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rGamma95)]*,* also known as *views*. An adapter is an object that delegates to a backing object, providing an alternative interface. Because an adapter has no state beyond that of its backing object, there’s no need to create more than one instance of a given adapter to a given object.

当一个对象是不可变的时，很明显它可以安全地重用，但是在其他情况下，它就不那么明显了，甚至是违反直觉的。考虑适配器的情况[Gamma95]，也称为视图。适配器是委托给支持对象的对象，提供可选接口。因为适配器除了它的支持对象之外没有其他状态，所以不需要为给定对象创建一个给定适配器的多个实例。 

For example, the `keySet` method of the `Map` interface returns a `Set` view of the `Map` object, consisting of all the keys in the map. Naively, it would seem that every call to `keySet` would have to create a new `Set` instance, but every call to `keySet` on a given `Map` object may return the same `Set` instance. Although the returned `Set` instance is typically mutable, all of the returned objects are functionally identical: when one of the returned objects changes, so do all the others, because they’re all backed by the same `Map` instance. While it is largely harmless to create multiple instances of the `keySet` view object, it is unnecessary and has no benefits.

例如，Map接口的keySet方法返回映射对象的一个集合视图，其中包含映射中所有的键。很简单，似乎每个对keySet的调用都必须创建一个新的Set实例，但是每个对给定映射对象的keySet的调用都可能返回相同的Set实例。虽然返回的Set实例通常是可变的，但是所有返回的对象在功能上都是相同的:当一个返回的对象发生变化时，其他的对象也会发生变化，因为它们都由相同的Map实例支持。虽然创建多个keySe实例基本上是无害的。

Another way to create unnecessary objects is *autoboxing*, which allows the programmer to mix primitive and boxed primitive types, boxing and unboxing automatically as needed. **Autoboxing blurs but does not erase the distinction between primitive and boxed primitive types.** There are subtle semantic distinctions and not-so-subtle performance differences ([Item 61](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev61)). Consider the following method, which calculates the sum of all the positive `int` values. To do this, the program has to use `long` arithmetic because an `int` is not big enough to hold the sum of all the positive `int` values:

另一种创建不必要对象的方法是自动装箱，它允许程序员根据需要自动混合原始类型和封装原始类型、装箱和开箱。自动装箱模糊但并没有消除原始和装箱原始类型之间的区别。有微妙的语义差异和不那么微妙的性能差异(第61项)。考虑下面的方法，它计算所有正整数的和。要做到这一点，程序必须使用长算术，因为int不能容纳所有正int值的总和: 

```java
// Hideously slow! Can you spot the object creation?

private static long sum() {

    Long sum = 0L;

    for (long i = 0; i <= Integer.MAX_VALUE; i++)

        sum += i;



    return sum;

}
```

This program gets the right answer, but it is *much* slower than it should be, due to a one-character typographical error. The variable `sum` is declared as a `Long` instead of a `long`, which means that the program constructs about 231 unnecessary `Long` instances (roughly one for each time the `long i` is added to the `Long sum`). Changing the declaration of `sum` from `Long` to `long` reduces the runtime from 6.3 seconds to 0.59 seconds on my machine. The lesson is clear: **prefer primitives to boxed primitives, and watch out for unintentional autoboxing.**

这个程序得到了正确的答案，但是由于一个字符的排版错误，它比它应该得到的要慢得多。变量和被声明为长而不是长，这意味着程序构造了大约$2^{31}$个不必要的长实例(每次将长i添加到长和中，大约为一个)。将sum声明从Long改为Long将运行时从6.3秒减少到0.59秒。教训是很清楚的:喜欢原语而不是盒装原语，并注意无意的自动装箱。 

This item should not be misconstrued to imply that object creation is expensive and should be avoided. On the contrary, the creation and reclamation of small objects whose constructors do little explicit work is cheap, especially on modern JVM implementations. Creating additional objects to enhance the clarity, simplicity, or power of a program is generally a good thing.

这个项目不应该被误解为意味着对象创建是昂贵的并且应该避免。相反，创建和回收构造函数很少显式工作的小对象是很便宜的，特别是在现代JVM实现中。创建额外的对象来增强程序的清晰度、简单性或功能通常是一件好事。 

Conversely, avoiding object creation by maintaining your own *object pool* is a bad idea unless the objects in the pool are extremely heavyweight. The classic example of an object that *does*justify an object pool is a database connection. The cost of establishing the connection is sufficiently high that it makes sense to reuse these objects. Generally speaking, however, maintaining your own object pools clutters your code, increases memory footprint, and harms performance. Modern JVM implementations have highly optimized garbage collectors that easily outperform such object pools on lightweight objects.

相反，通过维护自己的对象池来避免对象创建是一个坏主意，除非池中的对象是非常重量级的。定义对象池的典型例子是数据库连接。建立连接的成本非常高，因此重用这些对象是有意义的。但是，一般来说，维护自己的对象池会占用您的代码，增加内存占用，并损害性能。现代JVM实现具有高度优化的垃圾收集器，在轻量级上很容易胜过此类对象池。

The counterpoint to this item is [Item 50](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch8.xhtml#lev50) on *defensive copying*. The present item says, “Don’t create a new object when you should reuse an existing one,” while [Item 50](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch8.xhtml#lev50) says, “Don’t reuse an existing object when you should create a new one.” Note that the penalty for reusing an object when defensive copying is called for is far greater than the penalty for needlessly creating a duplicate object. Failing to make defensive copies where required can lead to insidious bugs and security holes; creating objects unnecessarily merely affects style and performance.

这个项目的对应物是关于防御性复制的第50项。现在的项目说，“当您应该重用一个现有的对象时，不要创建一个新的对象”，而项目50说，“当您应该创建一个新的对象时，不要重用一个现有的对象”。注意，在需要防御性复制时重用对象的惩罚远远大于不必要地创建重复对象的惩罚。未能在需要的地方制作防御副本可能导致潜在的错误和安全漏洞;创建不必要的对象只会影响样式和性能。 