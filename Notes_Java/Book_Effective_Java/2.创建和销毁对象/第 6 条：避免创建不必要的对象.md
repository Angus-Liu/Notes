## 第 6 条：避免创建不必要的对象

通常情况下，应当重用一个对象，而不是在每次需要时就创建一个功能相同的新对象。重用方式既快速，也更流行。如果一个对象是不可变的（immutable [第 17 条][item17]），那它总是可以被重用。 

作为一个极端的反面例子，考虑下面的语句： 

```java
String s = new String("bikini");  // 千万不要这么做！
```

该语句在每次执行时都创建一个新的 `String` 实例，但是这些对象的创建都是不必要的。传递给 `String` 构造器的参数 `("bikini")` 本身就是一个 `String` 实例，功能上与构造器创建的所有对象相同。如果这种用法出现在循环或频繁调用的方法中，就会创建成千上百万个不必要的 `String` 实例。 

改进后的版本如下: 

```java
String s = "bikini";
```

这个版本只使用了一个 `String` 实例，而不是在每次执行时都创建一个新的。此外，它可以保证，对于所有在同一虚拟机中运行的代码，只要它们包含相同的字符串字面量 [JLS, 3.10.5]，该对象就会被重用。 

对于同时提供了静态工厂方法（[第 1 条][item1]）和构造器的不可变类，通常可以使用静态工厂方法来避免创建不必要的对象。譬如，工厂方法 `Boolean.valueOf(String)` 就比构造器 `Boolean(String)` 更可取，后者已在 Java 9 中被弃用。构造器在每次被调用时都会创建一个新的对象，工厂方法则从来没有要求这样做，事实上也不会。除了重用不可变对象之外，如果知道对象不会被修改，还可以重用可变对象。 

某些对象的创建要比其他对象花费的代价高得多。如果反复需要这样一个“创建代价高昂的对象”（expensive object），那最好将其缓存以供重用。不幸的是，在创建这样的对象时，并不总是显而易见的。假设你要编写一个方法来判定字符串是否是有效的罗马数字。下面是使用正则表达式来进行此操作的最简单的方法: 

```java
// 性能还可以被大大提高!
static boolean isRomanNumeral(String s) {
    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
            + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```

这个实现的问题在于它依赖 `String.matches` 方法。**虽然 `String.matches` 是检查字符串是否与正则表达式匹配的最简单方法，但是它不适合在性能关键的情况下重复使用。**原因是，`String.matches` 方法会在内部为正则表达式创建一个 `Pattern` 实例，但只使用它一次，之后它就可以等待被进行垃圾收集了。创建一个 `Pattern` 实例代价高昂，因为需要将正则表达式编译成一个有限状态机。 

为了提高性能，可以显式地将正则表达式编译为一个 `Pattern` 实例（它是不可变的），将其作为类初始化的一部分，对它进行缓存，并在每次调用 `isRomanNumeral` 方法时重用同一个实例：

```java
// 重用创建代价高昂的对象以提高性能
public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile(
            "^(?=.)M*(C[MD]|D?C{0,3})"
            + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
    
    static boolean isRomanNumeral(String s) {
        return ROMAN.matcher(s).matches();
    }
}
```

如果经常调用，改进版的 `isRomanNumeral` 方法将提供显著的性能收益。在我的机器上，原始版本处理 8 字符的输入字符串花费了 1.1µs，而改进版本只需要 0.17µs，快了将近 6.5 倍。不仅性能得到了改善，而且清晰度也得到了提高。为不可见的 `Pattern` 实例创建静态 final 字段允许我们给它一个名称，而这个名称要比正则表达式本身可读性强得多。 

如果包含改进版本的 `isRomanNumeral` 方法的类被初始化，但该方法从未被调用，则 `ROMAN` 字段将不必要地被初始化。可以通过在第一次调用 `isRomanNumeral` 方法时，延迟初始化（lazily initializing）字段（[第 83 条](item83)）的方式来避免不必要地初始化，但是不建议这样做。延迟初始化通常会出现这样的情况，它会使实现复杂化，并且不会带来可观的性能改进（[第 67 条](item67)）。 

当一个对象是不可变的，显然它可以被安全地重用，但是在其他情况下，就不那么明显，甚至违反直觉。考虑适配器（adapter），也称为视图（view）的情况 [[Gamma95](#Gamma95)]。适配器是指提供了可替代的接口，来代表支撑对象（backing object）的对象。由于适配器除了它的支撑对象之外没有其他状态，所以不需要在特定适配器上为给定对象创建的多个适配器实例。 

例如，`Map` 接口的 `keySet` 方法会返回 `Map` 对象的一个 `Set` 视图，其中包含该 map 中所有的 key。初看起来，好像每次对 `keySet` 方法的调用都要创建一个新的 `Set` 实例，但事实上，对于一个给定的 `Map` 对象，每次对 `keySet` 方法的调用都可能返回相同的 `Set` 实例。虽然返回的 `Set` 实例通常是可变的，但是所有返回的对象在功能上是等同的：当其中一个返回对象发生变化时，其他的对象也会发生变化，因为它们都由相同的 `Map` 实例所支撑。虽然创建多个 `keySet` 视图对象的实例很大程度上没有害处，但没有必要，也没有好处。

Another way to create unnecessary objects is *autoboxing*, which allows the programmer to mix primitive and boxed primitive types, boxing and unboxing automatically as needed. **Autoboxing blurs but does not erase the distinction between primitive and boxed primitive types.** There are subtle semantic distinctions and not-so-subtle performance differences ([Item 61](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev61)). Consider the following method, which calculates the sum of all the positive `int` values. To do this, the program has to use `long` arithmetic because an `int` is not big enough to hold the sum of all the positive `int` values:

另一种会创建不必要对象的方法是自动装箱（autoboxing），它允许程序员根据需要自动混合原始类型和封装原始类型、装箱和开箱。自动装箱模糊但并没有消除原始和装箱原始类型之间的区别。有微妙的语义差异和不那么微妙的性能差异(第61项)。考虑下面的方法，它计算所有正整数的和。要做到这一点，程序必须使用长算术，因为int不能容纳所有正int值的总和: 

```java
// Hideously slow! Can you spot the object creation?

private static long sum() {

    Long sum = 0L;

    for (long i = 0; i <= Integer.MAX_VALUE; i++)

        sum += i;



    return sum;

}
```

This program gets the right answer, but it is *much* slower than it should be, due to a one-character typographical error. The variable `sum` is declared as a `Long` instead of a `long`, which means that the program constructs about 231 unnecessary `Long` instances (roughly one for each time the `long i` is added to the `Long sum`). Changing the declaration of `sum` from `Long` to `long` reduces the runtime from 6.3 seconds to 0.59 seconds on my machine. The lesson is clear: **prefer primitives to boxed primitives, and watch out for unintentional autoboxing.**

这个程序得到了正确的答案，但是由于一个字符的排版错误，它比它应该得到的要慢得多。变量和被声明为长而不是长，这意味着程序构造了大约$2^{31}$个不必要的长实例(每次将长i添加到长和中，大约为一个)。将sum声明从Long改为Long将运行时从6.3秒减少到0.59秒。教训是很清楚的:喜欢原语而不是盒装原语，并注意无意的自动装箱。 

This item should not be misconstrued to imply that object creation is expensive and should be avoided. On the contrary, the creation and reclamation of small objects whose constructors do little explicit work is cheap, especially on modern JVM implementations. Creating additional objects to enhance the clarity, simplicity, or power of a program is generally a good thing.

这个项目不应该被误解为意味着对象创建是昂贵的并且应该避免。相反，创建和回收构造器很少显式工作的小对象是很便宜的，特别是在现代JVM实现中。创建额外的对象来增强程序的清晰度、简单性或功能通常是一件好事。 

Conversely, avoiding object creation by maintaining your own *object pool* is a bad idea unless the objects in the pool are extremely heavyweight. The classic example of an object that *does*justify an object pool is a database connection. The cost of establishing the connection is sufficiently high that it makes sense to reuse these objects. Generally speaking, however, maintaining your own object pools clutters your code, increases memory footprint, and harms performance. Modern JVM implementations have highly optimized garbage collectors that easily outperform such object pools on lightweight objects.

相反，通过维护自己的对象池来避免对象创建是一个坏主意，除非池中的对象是非常重量级的。定义对象池的典型例子是数据库连接。建立连接的成本非常高，因此重用这些对象是有意义的。但是，一般来说，维护自己的对象池会占用您的代码，增加内存占用，并损害性能。现代JVM实现具有高度优化的垃圾收集器，在轻量级上很容易胜过此类对象池。

The counterpoint to this item is [Item 50](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch8.xhtml#lev50) on *defensive copying*. The present item says, “Don’t create a new object when you should reuse an existing one,” while [Item 50](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch8.xhtml#lev50) says, “Don’t reuse an existing object when you should create a new one.” Note that the penalty for reusing an object when defensive copying is called for is far greater than the penalty for needlessly creating a duplicate object. Failing to make defensive copies where required can lead to insidious bugs and security holes; creating objects unnecessarily merely affects style and performance.

这个项目的对应物是关于防御性复制的第50项。现在的项目说，“当您应该重用一个现有的对象时，不要创建一个新的对象”，而项目50说，“当您应该创建一个新的对象时，不要重用一个现有的对象”。注意，在需要防御性复制时重用对象的惩罚远远大于不必要地创建重复对象的惩罚。未能在需要的地方制作防御副本可能导致潜在的错误和安全漏洞;创建不必要的对象只会影响样式和性能。 



<p id="Gamma95">[Gamma95] Gamma,	Erich,	Richard	Helm,	Ralph	Johnson,	and	John	Vlissides.	1995. Design	Patterns:	Elements	of	Reusable	Object-Oriented	Software.	Reading, MA:	Addison-Wesley.	ISBN:	0201633612. </p>



> 翻译：Angus
>
> 校对：