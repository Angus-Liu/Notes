## 第 5 条：<u>使用依赖注入取代硬连接资源</u>【依赖注入优于资源硬连接（hardwiring resources）】

很多类依赖于一个或多个<u>基础</u>【潜在的】资源【（underlying resources）】。比如，一个拼写检查器~~（SpellChecker）~~依赖一<u>个</u>【本】词典。<u>一些类</u>【这种类被】实现为静态工具类【的情况】~~（[第 4 条](https://)）~~并不少见【（[第 4 条](item4)）】：

```JAVA
// 静态工具类的不恰当使用 - 不灵活 & 不可测试! 
public class SpellChecker { 
    private static final Lexicon dictionary = ...;
    
    private SpellChecker() {} // 不可实例化

    public static boolean isValid(String word) { ... }
    public static List<String> suggestions(String typo) { ... }
}

```

同样，<u>有些类</u>【它们被】实现为单例【的情况】也很常见：

```JAVA
// 单例的不恰当使用 - 不灵活 & 不可测试!
 public class SpellChecker { 
	private final Lexicon dictionary = ...;

	private SpellChecker(...) {} 
	public static INSTANCE = new SpellChecker(...);

	public boolean isValid(String word) { ... }
	public List<String> suggestions(String typo) { ... }
 }
```

[批注]: (//)	"这里不应该为有些类或是一些类，而应该就是指那些依赖潜在资源的那些类"

这两种方式<u>很</u>【都】不尽人意，【因为】他们~~都~~假设~~永远~~只有一<u>个</u>【本】字典<u>被应用</u>【会被使用】。事实上，每种语言都有<u>他</u>【它】自己的字典，【并且特定的词汇需要特殊的字典】<u>特殊词汇表会使用特殊的字典</u>。同样，用一<u>个</u>【本】特殊的字典来测试也是我们所期望的。妄想使用一<u>个</u>【本】字典满足所有的需求只是<u>一个理想</u>【一厢情愿】而已。

<u>你可能想到在 `SpellChecker` 中去掉 `dictionary` 的 `final` 属性然后添加一个方法来让 `SpellChecker` 支持多个字典</u>【为了使 `SpellChecker` 支持多本字典，你可以通过去掉 `dictionary` 的 `final` 属性，并添加一个改变现有拼写检查器的字典的方法来实现】，然而【在并发环境下，】这是有缺陷的，更容易导致错误，而且在并发环境中不可运行。**静态工具类和单例不适合应用于其行为被底层资源参数化的类**。

按照需求我们得支持多个类的实例（在我们的例子中是 `SpellChcker` ），在每个实例中使用客户端所需要的资源（在我们例子中是 `dictionary` ）。**在实例化时把依赖资源加入到构造器中**是一个便捷的方法。这是依赖注入（*`dependency injection`*）的一种形式：字典是拼写检查器的依赖（*`dependency`*）在 `SpellChecker` 对象被创建时注入到其构造方法中。

```java
	// 依赖注入提供了良好的灵活性和可测性
	public class SpellChecker {
		private final Lexicon dictionary;
        
		public SpellChecker(Lexicon dictionary) {
		this.dictionary = Objects.requireNonNull(dictionary);
		}
        
        public boolean isValid(String word) { ... }
        public List<String> suggestions(String typo) { ... }
    }
```

依赖注入的方法很多程序员常年都在使用却不知道它还有个名字。虽然我们的拼写检查器的例子只有一个简单的资源（`dictionary`），实际上依赖注入可以支持任意数量的资源和依赖图。它保证了程序的重用性（[第 17 条](..)），所以多个客户端可以同时共享依赖对象（假如客户端申请同一个底层资源）。依赖注入同样适用于构造器，静态工厂和构建器（[第 2 条](...)）等。

还有一种便捷的用法是给构造器传递一个资源工厂（*`factory`*），即创建类型实例时可以被反复调用的对象。比如工厂方法模式（*`the Factory Method pattern`*）。JAVA 8 中引入的 `Supplier<T>` 接口就是一个典型的资源工厂。当一个方法使用 `Supplier<T>` 作为输入参数时，应该通过使用边界通配符（*`bound wildcard type`* [第 31 条](..)）限制其工厂的类型参数，这样客户端就可以传入一个工厂来创建指定类型的子类型。比如下面这个例子，使用客户端提供的工厂来让 `mosaic` 方法创建 `tile` 类型的变量：

```java
	Mosaic create(Supplier<? extends Tile> tileFactory) { ... }
```

依赖注入大大提高了程序的灵活性和可测性，但当包含过多的依赖时依然会使项目杂乱无章。使用一些依赖注入框架（*`dependency injection framework`*）可以处理这个问题，比如 [Dagger]( http://square.github.io/dagger/), [Guice](https://github.com/google/guice), [Spring](https://projects.spring.io/spring-framework/)等。本书不讨论这些框架的用法，注意：没必要使用框架来实现一些常规的依赖注入。

总而言之，不要使用单例或静态类来实现一些依赖于底层资源的类，也不要使用类直接创建这些资源。相反，把资源传递到构造器，或者让工厂来创建它们。依赖注入的使用会大大提高类的灵活性、可重用性和测试性。

[item4]:url	"在未来填入第 4 条的 url，否则无法进行跳转"