## 第 1 条：考虑用静态工厂方法代替构造函数

​	对于类而言，允许客户端获取其实例的传统方式是提供一个公有的构造函数。但还有一种方法，也应该在每个程序员的工具箱中占有一席之地。类可以提供一个公有的静态工厂方法（static factory method），它只是一个返回类的实例的静态方法。下面是一个 `Boolean` 类型（基本类型 `boolean` 的包装类）的简单示例。这个方法将一个 `boolean` 基本类型值转换成了一个 `Boolean` 对象引用： 

```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

​	注意，静态工厂方法和“设计模式”中的“工厂方法模式”并不相同 \[Gamma95\][^1]。本条目描述的静态工厂方法在设计模式中没有直接的对等项。

​	类可以为其客户端提供静态工厂方法，而不是公有构造函数，或者说除了公有构造函数之外。提供静态工厂方法而非公有构造函数既有优点也有缺点。

​	**静态工厂方法相比构造函数第一个优点是，它们具有名称。**如果构造函数的参数本身没有描述返回的对象，则具有适当名称的静态工厂更易于使用，客户端生成的代码也更易于阅读。例如，构造函数`BigInteger(int, int, Random)` 返回的 `BigInteger` 可能为素数，它可以更好地用一个名为 `BigInteger.probablePrime` 的静态工厂方法来表示。（此方法是在 Java 4 中添加的。） 

​	一个类只能有一个具有给定签名的构造函数。程序员可以通过提供两个构造函数来避开这个限制，而这两个构造函数的参数列表仅在于参数类型的顺序不同。不过这是个非常糟糕的主意。因为这种API的用户将永远无法分清该使用哪一个，最终会导致错误的调用。在没有参考文档的情况下，当有人阅读使用了这些构造函数的代码时，也无法明白其中的意图。 

​	因为静态方法有名称，所以不受上述限制。如果某个类需要多个具有相同签名的构造函数时，请使用静态工厂方法替换构造函数，并且慎重地选择名称来突出它们之间的差异。

​	This allows immutable classes (Item 17) to use preconstructed instances, or to cache instances as they’re constructed, and dispense them repeatedly to avoid creating unnecessary duplicate objects. The Boolean.valueOf(boolean) method illustrates this technique: it never creates an object. This technique is similar to the Flyweight pattern [Gamma95]. It can greatly improve performance if equivalent objects are requested often, especially if they are expensive to create.    

​	**静态工厂方法相比构造函数的第二个优点是，不需要在每次被调用时都创建一个新对象。**这允许不可变类（[第17项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev17)）使用预构建的实例，或者在构造时缓存实例，并重复分配它们以避免创建不必要的重复对象。该`Boolean.valueOf(boolean)`方法说明了这种技术：它永远不会创建一个对象。这种技术类似于Flyweight模式[Gamma95]。如果经常请求等效对象，它可以极大地提高性能，特别是如果它们创建起来很昂贵。

静态工厂方法从重复调用返回同一对象的能力允许类在任何时候保持对存在的实例的严格控制。执行此操作的类被称为*实例控制。*编写实例控制类有几个原因。实例控制允许类保证它是单例（[第3项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch2.xhtml#lev3)）或不可实例化（[第4项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch2.xhtml#lev4)）。此外，它允许不可变值类（[第17项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev17)）保证不存在两个相等的实例：`a.equals(b)`if和only if `a == b`。这是*Flyweight*模式[ [Gamma95](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rGamma95) ]的基础。枚举类型（[第34项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch6.xhtml#lev34)）提供此保证。

**静态工厂方法的第三个优点是，与构造函数不同，它们可以返回其返回类型的任何子类型的对象。**这为您选择返回对象的类提供了极大的灵活性。

这种灵活性的一个应用是API可以在不公开其类的情况下返回对象。以这种方式隐藏实现类会导致API非常紧凑。这种技术适用于*基于接口的框架*（[第20项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev20)），其中接口为静态工厂方法提供自然返回类型。

在Java 8之前，接口不能有静态方法。按照惯例，名为interface的静态工厂方法`*Type*`放在名为的不可*实例化的伴随类*（[Item 4](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch2.xhtml#lev4)）中`*Types*`。例如，Java Collections Framework的接口有45个实用程序实现，提供不可修改的集合，同步集合等。几乎所有这些实现都是通过静态工厂方法在一个不可实例化的类（`java.util.Collections`）中导出的。返回对象的类都是非公共的。

Collections Framework API比它导出45个单独的公共类要小得多，每个方便实现一个。它不仅仅是减少了API 的*大部分*，而是*概念上的重量：*程序员为了使用API而必须掌握的概念的数量和难度。程序员知道返回的对象具有其接口指定的API，因此不需要为实现类读取其他类文档。此外，使用这种静态工厂方法需要客户端通过接口而不是实现类来引用返回的对象，这通常是一种很好的做法（[第64项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev64)）。

从Java 8开始，消除了接口不能包含静态方法的限制，因此通常没有理由为接口提供不可实例化的伴随类。许多公共静态成员应该放在接口本身中。但请注意，可能仍有必要将大量实现代码放在这些静态方法后面的单独的包私有类中。这是因为Java 8要求接口的所有静态成员都是公共的。Java 9允许私有静态方法，但静态字段和静态成员类仍然需要公开。

**静态工厂的第四个优点是返回对象的类可以随着调用而变化，作为输入参数的函数。**声明的返回类型的任何子类型都是允许的。返回对象的类也可能因发行版而异。

在`EnumSet`类（[36项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch6.xhtml#lev36)）没有公共构造函数，只有静态工厂。在OpenJDK实现中，它们返回两个子类之一的实例，具体取决于底层枚举类型的大小：如果它具有64个或更少的元素，就像大多数枚举类型那样，静态工厂返回一个`RegularEnumSet`实例，即由单一支持`long`; 如果枚举类型包含六十五个或更多元素，则工厂返回一个`JumboEnumSet`由`long`数组支持的实例。

这两个实现类的存在对于客户端是不可见的。如果`RegularEnumSet`不再为小型枚举类型提供性能优势，可以从未来的版本中消除它，没有任何不良影响。同样，未来版本可以添加第三或第四个实施，`EnumSet`如果它被证明是有益的表现。客户既不知道也不关心他们从工厂回来的物品的类别; 他们只关心它是它的一些子类`EnumSet`。

**静态工厂的第五个优点是，当写入包含该方法的类时，返回对象的类不需要存在。**这种灵活的静态工厂方法构成了*服务提供者框架*的基础，如Java数据库连接API（JDBC）。服务提供者框架是提供者实现服务的系统，系统使实现可用于客户端，将客户端与实现分离。

服务提供者框架中有三个基本组件：*服务接口*，代表一个实现; 一个*提供商注册API*，其提供用于注册的实现; 以及*服务访问API*，客户端使用它来获取服务的实例。服务访问API可以允许客户端指定用于选择实现的标准。如果没有这样的标准，API将返回默认实现的实例，或允许客户端循环遍历所有可用的实现。服务访问API是灵活的静态工厂，它构成了服务提供者框架的基础。

服务提供者框架的可选第四个组件是*服务提供者接口*，它描述了一个生成服务接口实例的工厂对象。在缺少服务提供者接口的情况下，必须反复实例化实现（[第65项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev65)）。在JDBC的情况下，`Connection`扮演服务接口的一部分，`DriverManager.registerDriver`是提供者注册API，`DriverManager.getConnection`是服务访问API，并且`Driver`是服务提供者接口。

服务提供者框架模式有许多变体。例如，服务访问API可以向客户端返回比提供者提供的服务接口更丰富的服务接口。这是*桥*模式[ [Gamma95](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rGamma95) ]。依赖注入框架（[第5项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch2.xhtml#lev5)）可视为强大的服务提供者。从Java 6开始，该平台包含一个通用服务提供程序框架，`java.util.ServiceLoader`因此您不需要（通常不应该）自己编写（[第59项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev59)）。JDBC不使用`ServiceLoader`，因为前者早于后者。

**仅提供静态工厂方法的主要限制是没有公共或受保护构造函数的类不能被子类化。**例如，不可能在Collections Framework中继承任何便捷实现类。可以说这可能是一种伪装的祝福，因为它鼓励程序员使用组合而不是继承（[第18项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev18)），并且是不可变类型（[第17项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev17)）所必需的。

**静态工厂方法的第二个缺点是程序员很难找到它们。**它们在API文档中并不突出构造函数这样做，因此很难弄清楚如何实例化一个提供静态工厂方法而不是构造函数的类。Javadoc工具有一天可能会引起对静态工厂方法的注意。在此期间，您可以通过引起对类或接口文档中的静态工厂的注意并遵守常见的命名约定来减少此问题。以下是静态工厂方法的一些常用名称。这份清单远非详尽无遗：

[^1]: [Gamma95] <br>Gamma, Erich, Richard Helm, Ralph Johnson, and John Vlissides. 1995.  <br>Design Patterns: Elements of Reusable Object-Oriented Software. <br>Reading, MA: Addison-Wesley. ISBN: 0201633612.