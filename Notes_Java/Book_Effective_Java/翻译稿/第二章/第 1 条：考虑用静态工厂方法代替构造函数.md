## 第 1 条：考虑用静态工厂方法代替构造函数

对于类而言，允许客户端获取其实例的传统方式是提供一个公有的构造函数。但还有一种方法，也应该在每个程序员的工具箱中占有一席之地。类可以提供一个公有的静态工厂方法（static factory method），它只是一个返回类的实例的静态方法。下面是一个 `Boolean` 类型（基本类型 `boolean` 的包装类）的简单示例。这个方法将一个 `boolean` 基本类型值转换成了一个 `Boolean` 对象引用： 

```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

注意，静态工厂方法和“设计模式”中的“工厂方法模式”并不相同 \[Gamma95\][^1]。本条目描述的静态工厂方法在设计模式中没有直接的对等项。

类可以为其客户端提供静态工厂方法，而不是公有构造函数，或者说除了公有构造函数之外。提供静态工厂方法而非公有构造函数既有优点也有缺点。

**静态工厂方法相比构造函数第一个优点是，它们具有名称。**如果构造函数的参数本身没有描述返回的对象，则具有适当名称的静态工厂更易于使用，客户端生成的代码也更易于阅读。例如，构造函数`BigInteger(int, int, Random)` 返回的 `BigInteger` 可能为素数，它可以更好地用一个名为 `BigInteger.probablePrime` 的静态工厂方法来表示。（此方法是在 Java 4 中添加的。） 

一个类只能有一个具有给定签名的构造函数。程序员可以通过提供两个构造函数来避开这个限制，而这两个构造函数的参数列表仅在于参数类型的顺序不同。不过这是个非常糟糕的主意。因为这种API的用户将永远无法分清该使用哪一个，最终会导致错误的调用。在没有参考文档的情况下，当有人阅读使用了这些构造函数的代码时，也无法明白其中的意图。 

因为静态方法有名称，所以不受上述限制。如果某个类需要多个具有相同签名的构造函数时，请使用静态工厂方法替换构造函数，并且慎重地选择名称来突出它们之间的差异。

**静态工厂方法相比构造函数的第二个优点是，不需要在每次被调用时都创建一个新对象。**这允许不可变类（[第17项][item17]）使用预先构建的实例，或者缓存构造好的实例，重复分配，以避免创建不必要的重复对象。 `Boolean.valueOf(boolean)` 方法就说明了这种技术：它从来不会创建一个对象。这种技术类似于享元（Flyweight ）模式 \[Gamma95\][^1]。如果经常请求相同的对象，特别是它们的创建成本较高，则这种方法可以极大地提高性能。 

静态工厂方法被重复调用时返回相同对象的能力，有助于类在任何时候严格控制哪些实例应该存在。执行此操作的类被称为实例受控的类（instance-controlled）。编写实例受控的类有几个原因。实例受控允许类保证它是一个单例（Singleton [第3项][item3]）或是不可实例化的（[第4项][item4]）。此外，它使得不可变类（[第17项][item17]）保证不存在两个相等的实例：即 `a.equals(b)` 当且仅当 `a == b` 。这就是享元模式（Flyweight pattern）\[Gamma95\][^1]的基础。枚举类型（[第34项][item34]）保证了这一点。

**静态工厂方法相比构造函数的第三个优点是，它们可以返回原返回类型的任何子类型的对象。**这使得你在选择返回对象的类时具有很大的灵活性。 

这种灵活性的一个应用是，API 可以在不使得类变得公有的情况下返回其对象。以这种方式隐藏实现类会让API非常简洁紧凑。这种技术适用于基于接口的框架（interface-based frameworks [第20项][item20]），其中接口为静态工厂方法提供自然返回类型。

在 Java 8 之前，接口不能有静态方法。按照惯例，接口 Type 的静态工厂方法放在名为 Types 的不可实例化的伴随类中（[Item 4][item4]）。例如，Java 集合框架（Java Collections Framework）的接口有 45 个便利的实现，提供了不可修改的集合、同步集合等。几乎所有的这些实现都是通过一个不可实例化类(`java.util.Collections`)中的静态工厂方法导出的。所有返回对象的类都是非公有的。

It is not just the bulk of the API that is reduced but the conceptual weight: the number and difficulty of the concepts that programmers must master in order to use the API. The programmer knows that the returned object has precisely the API specified by its interface, so there is no need to read additional class documentation for the implementation class. Furthermore, using such a static factory method requires the client to refer to the returned object by interface rather than implementation class, which is generally good practice (Item 64).    

每个便利实现都对应一个类，使得集合框架（Collections Framework） API的实现比由它直接导出45个独立的公有类的实现方式要小得多。减少的不仅仅是大部分API，还有概念上的权重：程序员为了使用API而必须掌握的概念的数量和难度。程序员知道返回的对象具有其接口指定的API，因此不需要为实现类读取其他类文档。此外，使用这种静态工厂方法需要客户端通过接口而不是实现类来引用返回的对象，这通常是一种很好的做法（[第64项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev64)）。

As of Java 8, the restriction that interfaces cannot contain static methods was eliminated, so there is typically little reason to provide a noninstantiable companion class for an interface. Many public static members that would have been at home in such a class should instead be put in the interface itself. Note, however, that it may still be necessary to put the bulk of the implementation code behind these static methods in a separate package-private class. This is because Java 8 requires all static members of an interface to be public. Java 9 allows private static methods, but static fields and static member classes are still required to be public.    

从Java 8开始，消除了接口不能包含静态方法的限制，因此通常没有理由为接口提供不可实例化的伴随类。许多公共静态成员应该放在接口本身中。但请注意，可能仍有必要将大量实现代码放在这些静态方法后面的单独的包私有类中。这是因为Java 8要求接口的所有静态成员都是公共的。Java 9允许私有静态方法，但静态字段和静态成员类仍然需要公开。

A fourth advantage of static factories is that the class of the returned object can vary from call to call as a function of the input parameters. Any subtype of the declared return type is permissible. The class of the returned object can also vary from release to release.    

**静态工厂的第四个优点是返回对象的类可以随着调用而变化，作为输入参数的函数。**声明的返回类型的任何子类型都是允许的。返回对象的类也可能因发行版而异。

The EnumSet class (Item 36) has no public constructors, only static factories. In the OpenJDK implementation, they return an instance of one of two subclasses, depending on the size of the underlying enum type: if it has sixtyfour or fewer elements, as most enum types do, the static factories return a RegularEnumSet instance, which is backed by a single long; if the enum type has sixty-five or more elements, the factories return a JumboEnumSet instance, backed by a long array.    

在`EnumSet`类（[36项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch6.xhtml#lev36)）没有公共构造函数，只有静态工厂。在OpenJDK实现中，它们返回两个子类之一的实例，具体取决于底层枚举类型的大小：如果它具有64个或更少的元素，就像大多数枚举类型那样，静态工厂返回一个`RegularEnumSet`实例，即由单一支持`long`; 如果枚举类型包含六十五个或更多元素，则工厂返回一个`JumboEnumSet`由`long`数组支持的实例。

The existence of these two implementation classes is invisible to clients. If RegularEnumSet ceased to offer performance advantages for small enum types, it could be eliminated from a future release with no ill effects. Similarly, a future release could add a third or fourth implementation of EnumSet if it proved beneficial for performance. Clients neither know nor care about the class of the object they get back from the factory; they care only that it is some subclass of EnumSet.    

这两个实现类的存在对于客户端是不可见的。如果`RegularEnumSet`不再为小型枚举类型提供性能优势，可以从未来的版本中消除它，没有任何不良影响。同样，未来版本可以添加第三或第四个实施，`EnumSet`如果它被证明是有益的表现。客户既不知道也不关心他们从工厂回来的物品的类别; 他们只关心它是它的一些子类`EnumSet`。

A fifth advantage of static factories is that the class of the returned object need not exist when the class containing the method is written. Such flexible static factory methods form the basis of service provider frameworks, like the Java Database Connectivity API (JDBC). A service provider framework is a system in which providers implement a service, and the system makes the implementations available to clients, decoupling the clients from the implementations.    

**静态工厂的第五个优点是，当写入包含该方法的类时，返回对象的类不需要存在。**这种灵活的静态工厂方法构成了*服务提供者框架*的基础，如Java数据库连接API（JDBC）。服务提供者框架是提供者实现服务的系统，系统使实现可用于客户端，将客户端与实现分离。

There are three essential components in a service provider framework: a service interface, which represents an implementation; a provider registration API, which providers use to register implementations; and a service access API, which clients use to obtain instances of the service. The service access API may allow clients to specify criteria for choosing an implementation. In the absence of such criteria, the API returns an instance of a default implementation, or allows the client to cycle through all available implementations. The service access API is the flexible static factory that forms the basis of the service provider framework.    

服务提供者框架中有三个基本组件：*服务接口*，代表一个实现; 一个*提供商注册API*，其提供用于注册的实现; 以及*服务访问API*，客户端使用它来获取服务的实例。服务访问API可以允许客户端指定用于选择实现的标准。如果没有这样的标准，API将返回默认实现的实例，或允许客户端循环遍历所有可用的实现。服务访问API是灵活的静态工厂，它构成了服务提供者框架的基础。

An optional fourth component of a service provider framework is a service provider interface, which describes a factory object that produce instances of the service interface. In the absence of a service provider interface, implementations must be instantiated reflectively (Item 65). In the case of JDBC, Connection plays the part of the service interface, DriverManager.registerDriver is the provider registration API, DriverManager.getConnection is the service access API, and Driver is the service provider interface.    

服务提供者框架的可选第四个组件是*服务提供者接口*，它描述了一个生成服务接口实例的工厂对象。在缺少服务提供者接口的情况下，必须反复实例化实现（[第65项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev65)）。在JDBC的情况下，`Connection`扮演服务接口的一部分，`DriverManager.registerDriver`是提供者注册API，`DriverManager.getConnection`是服务访问API，并且`Driver`是服务提供者接口。

There are many variants of the service provider framework pattern. For example, the service access API can return a richer service interface to clients than the one furnished by providers. This is the Bridge pattern [Gamma95]. Dependency injection frameworks (Item 5) can be viewed as powerful service providers. Since Java 6, the platform includes a general-purpose service provider framework, java.util.ServiceLoader, so you needn’t, and generally shouldn’t, write your own (Item 59). JDBC doesn’t use ServiceLoader, as the former predates the latter.    

服务提供者框架模式有许多变体。例如，服务访问API可以向客户端返回比提供者提供的服务接口更丰富的服务接口。这是*桥*模式[ [Gamma95](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rGamma95) ]。依赖注入框架（[第5项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch2.xhtml#lev5)）可视为强大的服务提供者。从Java 6开始，该平台包含一个通用服务提供程序框架，`java.util.ServiceLoader`因此您不需要（通常不应该）自己编写（[第59项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev59)）。JDBC不使用`ServiceLoader`，因为前者早于后者。

There are many variants of the service provider framework pattern. For example, the service access API can return a richer service interface to clients than the one furnished by providers. This is the Bridge pattern [Gamma95]. Dependency injection frameworks (Item 5) can be viewed as powerful service providers. Since Java 6, the platform includes a general-purpose service provider framework, java.util.ServiceLoader, so you needn’t, and generally shouldn’t, write your own (Item 59). JDBC doesn’t use ServiceLoader, as the former predates the latter.    

**仅提供静态工厂方法的主要限制是没有公共或受保护构造函数的类不能被子类化。**例如，不可能在Collections Framework中继承任何便捷实现类。可以说这可能是一种伪装的祝福，因为它鼓励程序员使用组合而不是继承（[第18项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev18)），并且是不可变类型（[第17项](https://www.safaribooksonline.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev17)）所必需的。

A second shortcoming of static factory methods is that they are hard for programmers to find. They do not stand out in API documentation in the way that constructors do, so it can be difficult to figure out how to instantiate a class that provides static factory methods instead of constructors. The Javadoc tool may someday draw attention to static factory methods. In the meantime, you can reduce this problem by drawing attention to static factories in class or interface documentation and by adhering to common naming conventions. Here are some common names for static factory methods. This list is far from exhaustive:    

**静态工厂方法的第二个缺点是程序员很难找到它们。**它们在API文档中并不突出构造函数这样做，因此很难弄清楚如何实例化一个提供静态工厂方法而不是构造函数的类。Javadoc工具有一天可能会引起对静态工厂方法的注意。在此期间，您可以通过引起对类或接口文档中的静态工厂的注意并遵守常见的命名约定来减少此问题。以下是静态工厂方法的一些常用名称。这份清单远非详尽无遗：



[^1]: [Gamma95] <br>Gamma, Erich, Richard Helm, Ralph Johnson, and John Vlissides. 1995.  <br>Design Patterns: Elements of Reusable Object-Oriented Software. <br>Reading, MA: Addison-Wesley. ISBN: 0201633612.

[item17]: url-for-item-17	"在未来填入第17条的url，不然无法跳转到指定网页"

[item3]: url-for-item-3	"在未来填入第3条的url，不然无法跳转到指定网页"

[item4]: url-for-item-4	"在未来填入第4条的url，不然无法跳转到指定网页"

[item34]: url-for-item-34	"在未来填入第34条的url，不然无法跳转到指定网页"

[item20]: url-for-item-20	"在未来填入第20条的url，不然无法跳转到指定网页"