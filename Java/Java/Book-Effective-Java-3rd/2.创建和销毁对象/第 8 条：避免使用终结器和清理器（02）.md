## 【第 8 条：】避免使用<u>终结器</u> 【终结器】(finalizer)和<u>清除方法</u> 【清理器】（cleaner）

**<u>终结器不可预测，通常都是不安全的，而且通常情况下都不是必须使用的方法。</u>【终结器（finalizer）具有不可预测性，通常比较危险，并且一般情况下也没有必要使用。】** <u>终止方法</u>【终结器】的使用会导致程序<u>执行的</u>【行为】不稳定，降低~~程序~~性能以及可移植性问题。<u>终止方法</u>【终结器】【只在】很少【的】情况下有用，在本<u>节</u>【条目】的后面部分会做介绍，但根据经验~~来看~~，你应该避免使用<u>这种机制</u>【它们】。<u>在 JAVA 9 中</u>【从 Java 9 开始，】<u>终止方法</u>【终结器】已经被弃用了，然而在一些 JAVA ~~函数~~库中依然可以看到它们的身影。<u>在 JAVA 9 中清理器是终结器的替代物</u>【Java 9 中替代终结器的是清理器（cleaner）】。**清理器比终结器<u>安全性更高一些</u>【危险性低一些】，但<u>依然</u>【仍然】是不可预测的，会使程序运行缓慢，通常情况下依然<u>是不必要的</u>【没必要使用】**。

[批注]:(//)	"终止：停止，不再继续。终结：完结、收场,形容最后结束的意思。依文意，“终结”更适合，所以全文后面出现“终止”的地方，直接替换为了“终结”，望理解 :)；对啦，将“依然”修改为“仍然”只是为了减少用词重复性"
[批注]:(//)	"Finalizer 和 Cleaner 均是 java.lang.ref 包中定义的 Java 类，不要被第二版误导。相比翻译成“XX方法”，或许，翻译成“XX器”或不翻译更合适，已修改为“XX器”，若觉得不好，可以全局替换"

【C++ 程序员被告知】不要把 <u>JAVA</u>【Java】 的终结器或清理器与 C++ 中的析构函数【（destructor）】当成类似的机制。在 C++ 中，析构函数是回收【一个】对象【所占用】资源的标准方法，<u>而且也是与构造函数配对的必要的函数</u>【是构造函数所必需的对应物】。在 Java 中，<u>垃圾回收机制回收不可用对象所占空间时是不需要程序员做额外工作的</u>【当一个对象变得不可达时，垃圾回收器会回收与该对象相关联的存储空间，不需要程序员做专门的工作】。C++ 的析构函数也可以【被用来】回收其他非内存资源，而在 <u>JAVA</u>【Java】 中，一般用 `try-with-resources` 或者 `try-finally` 块达到同样的目的（[第 9 条][item9]）。

[批注]: (//)	"Java 的垃圾回收机制是在对象不可达时（即从 GC Root 无法达到该对象）对其进行回收"

终结器和清理器不能保证其被<u>迅速</u>【及时】执行是<u>它的一大缺点</u>【它们的缺点之一】【 [JLS, 12.6]】。<u>当对象变得不可达时，终结器或清理器的执行时间是不固定的。</u>【从一个对象变得不可达开始到它的终结器或清理器被执行，所花费的时间是任意长的。】这意味着**不应该在终结器或清理器中执行任何<u>对时序要求严格</u>【注重时间（time-critical）】的任务**。比如，依靠终结器或清理器~~完成~~关闭已<u>达</u>【打】开文件【的】操作<u>会导致</u>【就是】严重错误，因为打开文件的描述符是一种很有限的资源。由于 JVM 会延迟执行终结器或清理器，所以大量文件会保留在打开状态，当一个程序不能再打开文件时，它可能会运行失败。

[批注]: (//)	"将“迅速”改为“及时“，是结合了《深入理解 JVM》一书，因 finalizer 和 cleaner 的执行是在 GC 时期，而 GC 具有不确定性，故这里强调的应该是它们不会被”及时“执行"

及时地执行终结器和清理器正是垃圾回收算法的【一个】主要功能，<u>然而这种算法在 JVM 实现中过程中却大变化很大，</u>【它在不同的 JVM 实现中差别很大。】<u>取决于</u>【依赖于】终结器或清理器执行<u>效率</u>【及时性】的程序<u>性能</u>【的表现】也可能<u>不同</u>【发现同样的变化】。这样的程序在你测试用的 JVM 平台上运行得非常好，<u>然后</u>【而】在你最重要的客户的 JVM 平台上却根本无法运行，这种情况是完全有可能发生的。

<u>缓慢终止</u>【延迟终结过程】不仅仅只是一个理论上的问题。给一个类添加终结器<u>可以</u>【会】任意地延迟<u>回收该类实例的过程</u>【其实例的回收过程】。我的一位同事在调试一个长期运行的 GUI 应用时，程序莫名其妙报了~~内存溢出（~~ `OutOfMemoryError` ~~）~~的错误，然后<u>谜之崩溃</u>【死掉】。<u>我们分析程序崩溃的原因时发现</u>【分析表明其死掉的时期】，~~这个~~应用程序的终结器队列中有成千上万个图【形】对象（graphics objects）在等着被终结和回收。不幸的是【，】这个终结器线程【的优先级】比该程序的其它线程的优先级低，所以这些对象<u>终止</u>【被终结】的速度<u>不能达到它本应该达到</u>【比不上它们进入终结状态】的速度。<u>JAVA</u>【Java】 语言【规范】并不能保证哪个线程会执行终结器，所以除了避免使用终结器之外，没有别的【简便】方法来<u>防止</u>【避免】这类问题。在这方面清理器比终结器好一点，因为类的作者可以控制<u>该类的</u>【自己的】清理器线程，但是清理器依然会在垃圾回收器的控制下在后台运行，所以也不能保证及时<u>清理器的及时运行</u>【清理】。

<u>JAVA</u>【Java】 语言【规范】不仅不能保证终结器或清理器<u>的及时执行</u>【及时地执行】，它甚至都不能保证它们会被执行。当【一个】程序终止时，某些已经无法访问的对象的终结器却根本没有执行，这也是完全有可能的情况。所以，**永远不要<u>使用</u>【依赖】终结器或清理器来更新重要的持久状态**。比如，<u>使用</u>【依赖】终结器或清理器释放共享资源（比如数据库）上的<u>永久</u>【持久】锁【（persistent lock）】，很容易让整个分布式系统垮掉。

不要被 `System.gc`  和 `System.runFinalization` 这两个方法<u>诱导</u>【迷惑】。它们可能会提高终结器或清理器被执行的几率，但也不保证它们一定会被执行。有两种方法曾经作出这样的保证：`System.runFinalizersOnExit` 和它【臭名昭著】的兄弟 `Runtime.runFinalizersOnExit` 【方法】。~~然而~~这些方法【都】有致命缺陷【，】并且已经被<u>贬低了十几年</u>【废弃了数十年】[ [ThreadStop](#ThreadStop)]。

终结器存在另外一个问题，在终结过程中抛出的未被捕获的异常会被忽略，并且~~会停止~~对象的终止过程【也会终止】 [JSL, 12.6]。<u>这些被忽略</u>【未捕获】的异常会使其他对象处于~~被~~破坏（a corrupt state）的状态。如果其他线程【试图】使用~~了~~这些被破坏的对象，将会导致任意<u>不可预测的结果</u>【不确定的行为】。<u>一般地</u>【通常】，未被捕获的异常会~~终止~~终止线程并打印出栈轨迹（stack trace），但<u>在</u>【发生在】终结器中却不会这么做——它【甚至】不会打印出任何一条警告信息。清理器没有这个问题，因为使用清理器的库可以控制它的线程。

**使用终结器或清理器会导致严重的性能损失**。在我的机器上【，】创建一个简单的 `AutoCloseable` 对象【，】使用 `try-with-resources` 来关闭它【，】并让垃圾回收器回收<u>其所占用的资源</u>【它】所用的时间<u>仅仅只有</u>【大约是】 12ns<u>，</u>【。】~~而~~使用终结器【反而使时间增加】~~达~~到了 550 ns。换句话说，使用终结器创建并销毁对象~~比不使用它时间~~慢了【大约】 50 倍。主要是因为终结器抑制了高效的垃圾回收。如果你使用清理器来清除类的【所有】实例，【其】速度和终结器差不多（在我的机器上<u>野差不多是 500ns</u>【，清除每个实例所花费的时间大约是 500 ns】），但如果你【只是】把<u>清理器</u>【它们】作为安全网（safety net）来使用，清理器【的】速度将会快的多【，如下所述】。在这种情况下，创建、清除并销毁对象在我的机器上花了 66 ns，这意味着如果你不<u>适</u>【使】用安全网，<u>为了保险你要付出 5 倍（不是50）的代价</u>【你要为之支付 5 倍（不是 50 倍）的保险费】。

**终结器还有一个严重的安全问题：它们<u>会使</u>【打开】你的类【致使其】受到终结器攻击**（finalizer attacks）。<u>终结器攻击</u>【终结器攻击背后的思想】很简单：如果从构造器或它的序列化等价物 —— `readObject` 和 `readResolve` 方法<u>（[第 12 条][Item12]）</u>【（[第 12 章](chapter12)）】中抛出一个异常，【那么】恶意子类的终结器就可以在部分构造的对象上运行，而这些对象本应该<u>“死在藤蔓上”</u>【夭折 】。这个终结器可以在静态字段中记录【一个该】对象的引用，从而防止对该对象进行垃圾回收。<u>一旦记录了格式错误的对象（malformed object），在这个早就应该被销毁的对象上任意调用方法就会变得非常简单。</u>【一旦畸形的对象被记录下来，在这个不应该被允许存在的对象上调用任意的方法会变得非常简单。 】**从构造器中抛出异常<u>时，对象就不应该被创建，而终结器面前却不是这样。</u>**【**应该足以阻止对象的产生；但在终结器存在的情况下，却并非如此。 **】这样的攻击会导致可怕的结果。final 类避免了终结器攻击【，】因为没人能<u>给 final 类添加一个</u>【编写 final 类的】恶意子类。**为了<u>让非 final 类避免</u>【保护非 final 类不受】终结器攻击，<u>请</u>【可以编】写一个不执行任何操作的 <u>final 终止</u>【 finalize 】方法 **。

那么对于对象【中】封装【的】资源【确实】需要被终止的类，比如文件或线程~~相关类~~，<u>不使用</u>【除了编写】其终结器或清理器，你应该怎么做呢？**【可以】让你的类实现 `AutoCloseable` 接口**，并且<u>让</u>【要求该类的】客户端在每个实例不~~在~~【再】被需要时调用 `close` 方法，通常使用 `try-with-resources` <u>保证一旦出现异常确保其终结（[第 9 条][Item9]）</u>【来确保即使出现异常时亦能正常终止（[第 9 条][item9]）】。有个值得注意的细节，实例必须持续跟踪<u>它</u>【自己】是否被关闭：`close` 方法必须在一个<u>字段</u>【域】中记录该对象<u>是无效的</u>【不再是有效的】，<u>然后另一个方法必须检查这个字段，如果在该对象已经~~被~~关闭后请求则抛出 `IllegalStateException` 异常。</u>【如果该对象中的其他方法在对象被关闭之后调用，它们就必须检查这个域，并抛出 `IllegalStateException` 异常。 】

那么，终结器和清理器有没有什么用处呢？它们可能有两种合法用途。【第】一种用途是当对象的所有者忘记调用前面段落中建议使用的 `close` 方法的时，它们可以作为安全网（safety net）。虽然不能保证清理器或终结器会及时运行（或者根本不运行），<u>那也比如果客户端不调用就永远不释放资源强得多</u>【但在客户端无法正常结束操作的情况下，迟一点释放资源总比永远不释放要好】。如果你正考虑【编】写【这样一个】安全网终结器，建议你三思~~这种额外的保护~~是否值得<u>你付出这份额外的</u>【为这种保护付出】代价。【一些 Java 库中的类，】比如 `FileInputStream`、`FileOutputStream`、`ThreadPoolExecutor` 和 `java.sql.Connection` ~~这些依赖库类，就使用的作为安全网的终结器。~~【，就把终结器作为了安全网。】

<u>另一种清理器的合法用途与本地对等体（native peer）有关</u>【清理器的第二种合法用途与对象的本地对等体有关（native peer）】。本地对等体是一个本地对象（native object，非 Java 对象），普通对象通过本地方法（native method）委托给一个本地对象。因为本地对等体不是【一个】普通对象，~~所以~~垃圾回收器并不知道它的存在，所以当它的 Java 对等体被回收的时候它不会被回收。假设程序性能是可接受的而且本地对等体不含有关键资源，这样的情况下，清理器或终结器<u>正好</u>【或许】能派上用场。如果性能<u>不可接受</u>【不允许】或者本地对等体<u>含</u>【持】有必须被及时回收的资源，你应该<u>使用</u>【为类添加】前面段落中建议的 `close` 方法。

清理器使用起来有些棘手。下面用一个简单的 `Room` 类演示一下。假设 `Room` 的对象必须在它被回收前清除。`Room` 类实现了 `AutoCloseable` 接口<u>，</u>【；】<u>意味着它可以使用清理器自动清除安全网。</u>【事实上，它的自动清除安全网使用的仅仅是清理器的一个具体实现。】与终结器不同，清理器不会污染类的公共 API：

```java
// 一个实现了 AutoCloseable 接口使用清理器作为安全网的类
public class Room implements AutoCloseable {
    private static final Cleaner cleaner = Cleaner.create();
    
    // 需要清除的资源，不要牵涉到 Room 对象!
    private static class State implements Runnable {
        int numJunkPiles; // 房间里的垃圾堆数量
        State(int numJunkPiles) {
            this.numJunkPiles = numJunkPiles;
        } 
        
        // 由 close 方法或清理器调用
        @Override 
        public void run() {
            System.out.println("Cleaning room");
            numJunkPiles = 0;
        }
    } 
    // 这个房间的状态, 与我们定义的 cleanable 共享
    private final State state;
    // 我们定义的 cleanable. 当可以获得垃圾回收器时清理房间
    private final Cleaner.Cleanable cleanable;
    public Room(int numJunkPiles) {
        state = new State(numJunkPiles);
        cleanable = cleaner.register(this, state);
    } 
    @Override 
    public void close() {
        cleanable.clean();
    }
}
```

静态内部类 `State` 含有清理器<u>所需要的资源来清理房间</u>【清理房间所需的资源】。【本例中，】使用 `numJunkPiles` 变量简单的表示房间<u>中的垃圾</u>【的脏乱程度】。更<u>实际</u>【确切】地说，它可能包含了一个指向本地对等体的 `long` 常量指针。`State` 【类】实现了`Runnable` 接口并且它的 `run` 方法只能被 `Cleanable` 【对象】调用一次，<u>`cleanbale` 就是在 `Room` 构造器中把带有清理器的 `State` 的实例添加时获得的对象</u>【`Cleanable` 对象是在 `Room` 的构造器中注册 `State` 实例时获得的 】。<u>run 方法的调用会触发两件事：通常 Room 的 close 方法的调用会触发 Cleanable 的 clean 方法。如果在 Room 实例可以被回收时客户端调用 close 方法失败，清理器将会有效的调用 State 类的 run 方法</u>【对 `run` 方法的调用将由以下两种情况之一触发：通常是通过调用 `Room` 的 `close` 方法，继而调用 `Cleanable` 的 `clean` 方法 来触发。其次，当一个 `Room` 实例适合进行垃圾回收时，若客户端没有调用它的 `close` 方法，那么清理器将（有望）调用 `State` 的 `run` 方法】。

<u>`State` 实例与 `Room` 实例无关</u>【一个 `State` 实例不应该引用其对应的 `Room` 实例】，这一点至关重要。<u>如果不是的话</u>【否则】，将会【出现循环引用】使 【得】`Room` 实例变得不可被回收（也不会被自动清理）。【因为】非静态内部类包含<u>对它们封闭实例</u>【其外部类实例】的引用（[第 24 条][Item24]），因此，`State` 必须是静态内部类。同样，使用 lambda 表达式也是不可取的，因为它们可以轻易捕获<u>对封闭对象</u>【外部类对象】的引用。

[备注]: (//)	"lambda 表达式等同于匿名非静态内部类，保有外部类对应的一个引用，即外部类的 this"

<u>前面段落中提到</u>【正如前文所述】，`Room` 的清理器仅仅是用来作为安全网的。如果客户端把所有 Room 对象【的实例化过程】包含在 try-with-resource 块中~~实例化~~，就<u>再也不需要</u>【不再需要】自动清理了。下面这个<u>行为良好</u>【功能良好】的客户端演示了这种方式：

```java
public class Adult {
    public static void main(String[] args) {
        try (Room myRoom = new Room(7)) {
            System.out.println("Goodbye");
        }
    }
}
```

<u>运行 Adult 程序，会向你期望的那样，在清理房间后输出 Goodbye。那么永远不会清扫房间的坏程序是怎样的呢？</u>【如你所愿，Adult 程序运行后会先打印出“Goodbye”，随后会打印“Cleaning room”。那么对于那些“不打扫自己的房间”，功能不正常的程序是怎么样的呢？】

[批注]: (//)	"这里的“Cleaning room”由上面的run方法被调用时打印出来（代码建议自己实际跑一下，会加深理解）"

```java
public class Teenager{
    public static void main(String[] args){
        new Room(99);
        System.out.println("Peace out");
    }
}
```

<u>你可能会期望它在清理完房间后打印出 Peace out</u>【你或许期望它会先打印出“Peace out”，随后打印出“Cleaning room”】，然而在我的机器上，它【直接退出，】从没有打印过“Cleanning room”~~，它只会退出程序~~。这就是我们之前谈到的不可预测性。清理器的规范<u>这样说</u>【指出】：“<u>在 `System.exit` 的过程中清理器的行为是具体的。</u>【清洁器在 `System.exit` 方法执行期间的行为是特定于实现的。】关于是否调用清除操作并没有保证。”<u>即使规范不这么说，对于正常程序退出也是如此。</u>【虽然规范中没有提到，但普通程序退出时也是如此。 】在我的机器上，给 `Teenager` 的 `main` 方法添加`System.gc()` 【这一行】就可以让它在退出程序前打印出 `Cleaning room`  ，但不保证~~你~~能在你的电脑上看到同样的情形。

总之，不要使用清理器或~~在~~ Java 9 之前的终结器，除非作为安全网或【用来】终止非关键的本地资源。即使这样，也要<u>注意</u>【当心】不确定性和性能<u>带来的后果</u>【影响】。



<p id="Gamma95">[ThreadStop] Why Are Thread.stop, Thread.suspend, Thread.resume and Runtime.runFinalizersOnExit Deprecated? 1999. Sun Microsystems. <https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html>



[item9]: url	"在未来填入第 9 条的 url，否则无法进行跳转"
[item12]: url	"在未来填入第 12 条的 url，否则无法进行跳转"
[item24]: url	"在未来填入第 24 条的 url，否贼无法进行跳转"
[chapter21]: url	"在未来填入第 21 章的 url，否则无法进行跳转"



> 翻译：Injer
>
> 校对：Angus