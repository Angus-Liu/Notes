# 第 4 条：通过私有构造器强化不可实例化的能力

有时候，你可能需要编写~~一个~~只包含静态方法和静态属性的类。这些类~~有着不好的~~名声很不好，因为有些人【在面向对象的语言中使用】滥用它们【从而以面向过程的思想编写程序】~~以避免在对象的角度进行思考~~，但是它们确实有【自己的使用价值】~~用~~。它们可用于以 java.lang.Math 或者 java.utill.Arrays 的方式把初始值或数组~上~的相关方法进行组合，~~它们还~~【也】可用于以 java.util.Collections 的方式~~为实现某些接口的对象对~~【实现某些接口对象的】静态方法（~~包括~~【比如静态】工厂【方法】（[第 1 条][item1]））~~进行~~组合（自 Java 8 开始，你也可以把这些方法~~放到~~【写进你定义的】接口中~~，假设那是你的修改~~）。最后，这些类【还】可【以】用于把 final 类~~上~~【中】的方法进行组合，因为~~不能把它们放到子类中~~【final 类不可以被继承】。

> group 组合这个概念有点模糊，感觉可以查查资料搞清楚静态类换一个更生动明了的词。

这样的~~实用~~工具类（*utility class*）~~不是为实例化而设计的~~【不需要被实例化】，它的实例是没有意义的。 ~~然而，~~【因为】当缺乏显~~示~~【式】构造器时，编译器会提供一个公有的、无参~~数~~的默认构造器（*default constructor*）。对~~使用者~~【用户】而言，这个构造器和其它~~任何~~构造器~~都~~是没有【任何】区别的。在已发布的 API 中，【经常可以看到一些被无意识地实例化的类】~~无意中发现可实例化的类并不罕见~~。

**~~企图通过使一个类抽象来强制不可实例化是行不通的~~【企图使用抽象类来强制其不可被实例化是行不通的】**。  该【抽象】类可以被~~子类~~【实例】化，并且【其】子类也可以【被】实例化。【除】此【之】外，它【还】会误导读者认为~~该~~【抽象】类是为继承而设计的（[第 19 条][item19]）。~~然而~~【其实】，~~这~~有一个简单的~~习惯用法~~【常用手法】来确保【类的】不可实例化。只有当一个类不包含显~示~【式】构造器时，才会生成一个默认的构造器。所以**通过【添加】~~包含~~私有构造器，可以使类不可实例化**。【：】

```java
// 不可实例化工具类
public class UtilityClass {
    //	禁止默认构造器【，】以实现非实例化
    private UtilityClass() {
        throw new AssertionError();
    }
    // ..
    // 其余省略
}
```

因为显~~示~~【式】构造器是私有的，所以在类外~~面~~是不可访问的。AssertionError 并不是严格需要的，但它~~提供了保险~~【可以防止在类内意外调用构造器】~~，以防止从类中意外的调用构造器。~~，它【可以】保证类在任何环境下都绝不可能被实例化。~~这个习惯用法~~【这种风格的程序】有点违反直觉，因为构造器是明确提供的【却是为了该构造器[它]无法被调用】~~，以便它无法被调用~~。因此~~。明智的做法就是包含一条注释，如前面所示~~【，如上面所示那样添加一条注释不失为一个明了的写法】。

~~作为副作用，~~这个习惯用法也【有一些副作用，它同时也】阻止了【该】类被~~实例~~【子类】化。【因为该类中】所有的构造器必须显~~示~~【式】或隐式~~的~~【地】调用一个超类（*superclass*）构造器，在这种情况下，子类就没有可以访问的超类构造器来调用了。


[item1]:https://github.com/learning-and-thinking/Effective-Java-3rd-Edition-zh/blob/master/2.%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/%E7%AC%AC%201%20%E6%9D%A1%EF%BC%9A%E8%80%83%E8%99%91%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%99%A8.md
[item19]:url	"在未来填入第 19 条的 url，否则无法进行跳转"

---

> 翻译：Inno
>
> 校对：Inger




