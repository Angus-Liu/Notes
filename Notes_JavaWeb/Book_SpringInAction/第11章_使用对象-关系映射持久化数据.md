在数据持久化的世界中，JDBC就像自行车。对于份内的工作，它能很好地完成并且在一些特定的场景下表现出色。但随着应用程序变得越来越复杂，对持久化的需求也变得更复杂。如果能将对象的属性映射到数据库的列上，并且自动生成语句和查询，这样就能从无休止的问号字符串中解脱出来。此外，可能还需要一些更复杂的特性：

- 延迟加载（Lazy loading）：随着对象关系变得越来越复杂，有时候并不希望立即获取完整的对象间关系。假设在查询一组PurchaseOrder对象，而每个对象中都包含一个LineItem对象集合。如果只关心PurchaseOrder的属性，那查询出LineItem的数据就毫无意义。延迟加载允许只在需要的时候获取数据。
- 预先抓取（Eager fetching）：这与延迟加载是相对的。借助于预先抓取，可以使用一个查询获取完整的关联对象。如果需要PurchaseOrder及其关联的LineItem对象，预先抓取的功能可以在一个操作中将它们全部从数据库中取出来，节省了多次查询的成本。
- 级联（Cascading）：有时，更改数据库中的表会同时修改其他表。例如，当删除Order对象时，希望同时在数据库中删除关联的LineItem。

一些可用的框架提供了这样的服务，这些服务的通用名称是对象/关系映射（object-relational mapping，ORM）。

Spring对多个持久化框架都提供了支持，包括Hibernate、iBATIS、Java数据对象（Java Data Objects，JDO）以及Java持久化API（Java Persistence API，JPA）。与Spring对JDBC的支持那样，Spring对ORM框架的支持提供了与这些框架的集成点以及一些附加的服务：

- 支持集成Spring声明式事务；
- 透明的异常处理；
- 线程安全的、轻量级的模板类；
- DAO支持类；
- 资源管理。

### 11.1 在Spring中集成Hibernate

Hibernate提供了基本的对象关系映射，以及ORM工具所应具有的所有复杂功能，比如缓存、延迟加载、预先抓取以及分布式缓存。

书籍参：[《Java Persistence with Hibernate》](https://book.douban.com/subject/24830009/)，官网：<http://www.hibernate.org>。

#### 11.1.1 声明Hibernate的Session工厂

使用Hibernate所需的主要接口是org.hibernate.Session。Session接口提供了基本的数据访问功能，如保存、更新、删除以及从数据库加载对象的功能。通过Hibernate的Session接口，应用程序的Repository能够满足所有的持久化需求。

获取Hibernate Session对象的标准方式是借助于Hibernate SessionFactory接口的实现类。除了一些其他的任务，SessionFactory主要负责Hibernate Session的打开、关闭以及管理。

在Spring中，提供了三个Hibernate Session工厂bean来获取Hibernate SessionFactory：

+ org.springframework.orm.hibernate3.LocalSessionFactoryBean
+ org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean
+ org.springframework.orm.hibernate4.LocalSessionFactoryBean

这些Session工厂bean都是Spring FactoryBean接口的实现，它们会产生一个HibernateSessionFactory，它能够装配进任何SessionFactory类型的属性中。

如果使用Hibernate 3.2或更高版本（Hibernate 4.0之下）并且使用XML定义映射的话，那么需要定义Spring的org.springframework.orm.hibernate3包中的LocalSessionFactoryBean：

```java
@Bean
public LocalSessionFactoryBean sessionFactory(DataSource dataSource) {
    LocalSessionFactoryBean sfb = new LocalSessionFactoryBean();
    // 属性dataSource装配了一个DataSource bean的引用
    sfb.setDataSource(dataSource);
    // 属性mappingResources列出了一个或多个的Hibernate映射文件，在这些文件中定义了应用程序的持久化策略
    sfb.setMappingResources(new String[] { "Spitter.hbm.xml" });
    // hibernateProperties属性配置了Hibernate如何进行操作的细节
    Properties props = new Properties();
    // 这里，配置Hibernate使用H2数据库并且要按照H2Dialect来构建SQL
    props.setProperty("dialect", "org.hibernate.dialect.H2Dialect");
    sfb.setHibernateProperties(props);
    return sfb;
}
```

更倾向于使用注解的方式来定义持久化，并且还没有使用Hibernate 4的话，那么需要使用AnnotationSessionFactoryBean来代替LocalSessionFactoryBean：

```java
@Bean
public AnnotationSessionFactoryBean sessionFactory(DataSource ds) {
    AnnotationSessionFactoryBean sfb = new AnnotationSessionFactoryBean();
    sfb.setDataSource(ds);
    sfb.setPackagesToScan(new String[] { "com.habuma.spittr.domain" });
    Properties props = new Properties();
    props.setProperty("dialect", "org.hibernate.dialect.H2Dialect");
    sfb.setHibernateProperties(props);
    return sfb;
}
```

如果使用Hibernate 4的话，那么就应该使用org.springframework.orm.hibernate4中的LocalSessionFactoryBean。它有很多相同的属性，能够支持基于XML的映射和基于注解的映射。如下的代码展现了如何对它进行配置，使其支持基于注解的映射：

```java
@Bean
public LocalSessionFactoryBean sessionFactory(DataSource dataSource) {
    LocalSessionFactoryBean sfb = new LocalSessionFactoryBean();
    sfb.setDataSource(dataSource);
    // 这里不再列出Hibernate配置文件，
    // 而是使用packagesToScan属性告诉Spring扫描一个或多个包以查找域类，
    // 这些类通过注解的方式表明要使用Hibernate进行持久化，
    // 这些类可以使用的注解包括JPA的@Entity或@MappedSuperclass以及Hibernate的@Entity
    sfb.setPackagesToScan(new String[] { "com.habuma.spittr.domain" });
    Properties props = new Properties();
    props.setProperty("dialect", "org.hibernate.dialect.H2Dialect");
    sfb.setHibernateProperties(props);
    return sfb;
}
```

还可以使用annotatedClasses属性来将应用程序中所有的持久化类以全限定名的方式明确列出：

```java
// annotatedClasses属性对于准确指定少量的域类是不错的选择
sfb.setAnnotatedClasses(
    new Class<?>[] { Spitter.class, Spittle.class }
);
```

#### 11.1.2 构建不依赖于Spring的Hibernate代码

为了尽量避免Repository实现会直接与Spring耦合，最佳实践是不再使用Spring提供的HibernateTemplate，而是使用上下文Session（Contextual session）直接将Hibernate SessionFactory装配到Repository中，并使用它来获取Session：

```java
// @Repository是Spring的另一种构造性注解，它能够像其他注解一样被Spring的组件扫描所扫描到，
// 这样就不必明确声明HibernateSpitterRepository bean
@Repository
public class HibernateSpittleRepository implements SpittleRepository {

    private SessionFactory sessionFactory;

    // 注入SessionFactory
    @Inject
    public HibernateSpittleRepository(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    // 使用当前session
    private Session currentSession() {
        return sessionFactory.getCurrentSession();
    }

    public long count() {
        return findAll().size(); 
    }

    public List<Spittle> findRecent() {
        return findRecent(10);
    }

    public List<Spittle> findRecent(int count) {
        return (List<Spittle>) spittleCriteria()
            .setMaxResults(count)
            .list();
    }

    public Spittle findOne(long id) {
        return (Spittle) currentSession().get(Spittle.class, id);
    }

    public Spittle save(Spittle spittle) {
        Serializable id = currentSession().save(spittle);
        return new Spittle(
            (Long) id, 
            spittle.getSpitter(), 
            spittle.getMessage(), 
            spittle.getPostedTime());
    }

    public List<Spittle> findBySpitterId(long spitterId) {
        return spittleCriteria()
            .add(Restrictions.eq("spitter.id", spitterId))
            .list();
    }

    public void delete(long id) {
        currentSession().delete(findOne(id));
    }

    public List<Spittle> findAll() {
        return (List<Spittle>) spittleCriteria().list(); 
    }

    private Criteria spittleCriteria() {
        return currentSession() 
            .createCriteria(Spittle.class)
            .addOrder(Order.desc("postedTime"));
    }

}
```

@Repository还有另外一个用处。为了给不使用模板的Hibernate Repository添加异常转换功能，只需在Spring应用上下文中添加一个PersistenceExceptionTranslationPostProcessor bean：

```java
// PersistenceExceptionTranslationPostProcessor是一个bean 后置处理器（bean post-processor，Spring实例化Bean实例之后进行的增强处理），
// 它会在所有拥有@Repository注解的类上添加一个通知器（advisor），
// 这样就会捕获任何平台相关的异常并以Spring非检查型数据访问异常的形式重新抛出
@Bean
public BeanPostProcessor persistenceTranslation() {
    return new PersistenceExceptionTranslationPostProcessor();
}
```

### 11.2 Spring与Java持久化API

Java持久化API（Java Persistence API，JPA）基于POJO（Plain Ordinary Java Object，简单的Java对象 ）的持久化机制，从Hibernate和Java数据对象（Java Data Object，JDO）上借鉴了很多理念并加入了Java 5注解的特性。

在Spring中使用JPA的第一步是要在Spring应用上下文中将实体管理器工厂（entity manager factory）按照bean的形式来进行配置。

#### 11.2.1 配置实体管理器工厂

简单来讲，基于JPA的应用程序需要使用EntityManagerFactory的实现类来获取EntityManager实例。JPA定义了两种类型的实体管理器：

+ 应用程序管理类型（Application-managed）：当应用程序向实体管理器工厂直接请求实体管理器时，工厂会创建一个实体管理器。在这种模式下，程序要负责打开或关闭实体管理器并在事务中对其进行控制。这种方式的实体管理器适合于不运行在Java EE容器中的独立应用程序。
+ 容器管理类型（Container-managed）：实体管理器由Java EE创建和管理。应用程序根本不与实体管理器工厂打交道。相反，实体管理器直接通过注入或JNDI来获取。容器负责配置实体管理器工厂。这种类型的实体管理器最适用于Java EE容器，在这种情况下会希望在persistence.xml指定的JPA配置之外保持一些自己对JPA的控制。

应用程序管理类型的EntityManager是由EntityManagerFactory创建的，而后者是通过PersistenceProvider的createEntityManagerFactory()方法得到的。与此相对，容器管理类型的EntityManagerFactory是通过PersistenceProvider的createContainerEntityManagerFactory()方法获得的。

这两种实体管理器工厂分别由对应的Spring工厂Bean创建：

+ LocalEntityManagerFactoryBean生成应用程序管理类型的EntityManagerFactory；
+ LocalContainerEntityManagerFactoryBean生成容器管理类型的EntityManagerFactory。

**配置应用程序管理类型的JPA**

对于应用程序管理类型的实体管理器工厂来说，它绝大部分配置信息来源于一个名为persistence.xml的配置文件。这个文件必须位于类路径下的META-INF目录下。

persistence.xml列出了一个或多个的持久化类以及一些其他的配置如数据源和基于XML的配置文件。如下是一个典型的persistence.xml文件，它是用于Spittr应用程序的：

```xml
<persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">
    <persistence-unit name="spitterPU">
        <class>com.habuma.spittr.domain.Spitter</class>
        <class>com.habuma.spittr.domain.Spittle</class>
        <properties>
            <property name="toplink.jdbc.driver" value="org.hsqldb.jdbcDriver" />
            <property name="toplink.jdbc.url" value="jdbc:hsqldb:hsql://localhost/spitter/spitter" />
            <property name="toplink.jdbc.user" value="root" />
            <property name="toplink.jdbc.password" value="123456" />
        </properties>
    </persistence-unit>
</persistence>
```

因为在persistence.xml文件中包含了大量的配置信息，所以在Spring中需要配置的就很少了。可以通过以下的@Bean注解方法在Spring中声明LocalEntityManagerFactoryBean：

```java
@Bean
public LocalEntityManagerFactoryBean entityManagerFactoryBean() {
    LocalEntityManagerFactoryBean emfb = new LocalEntityManagerFactoryBean();
    // 赋给persistenceUnitName属性的值就是persistence.xml中持久化单元的名称
    emfb.setPersistenceUnitName("spitterPU");
    return emfb;
}
```

**使用容器管理类型的JPA**

容器管理的JPA采取了一个不同的方式。当运行在容器中时，可以使用容器（在这里是Spring）提供的信息来生成EntityManagerFactory。

可以将数据源信息配置在Spring应用上下文中，而不是在persistence.xml中了。例如，如下的@Bean注解方法声明了在Spring中如何使用LocalContainerEntityManagerFactoryBean来配置容器管理类型的JPA：

```java
@Bean
public LocalContainerEntityManagerFactoryBean entityManagerFactory(
    DataSource dataSource, JpaVendorAdapter jpaVendorAdapter) {
    LocalContainerEntityManagerFactoryBean emfb =
        new LocalContainerEntityManagerFactoryBean();
    // 使用了Spring配置的数据源来设置dataSource属性
    // 尽管数据源还可以在persistence.xml中进行配置，
    // 但是这个属性指定的数据源具有更高的优先级
    emfb.setDataSource(dataSource);
    // jpaVendorAdapter属性用于指明所使用的是哪一个厂商的JPA实现；
    // Spring提供了多个JPA厂商适配器：
    //  ● EclipseLinkJpaVendorAdapter
    //  ● HibernateJpaVendorAdapter
    //  ● OpenJpaVendorAdapter
    //  ● TopLinkJpaVendorAdapter（Spring 3.1中已废弃）
    emfb.setJpaVendorAdapter(jpaVendorAdapter);
    return emfb;
}
```

本例中，使用Hibernate作为JPA实现，所以将其配置为HibernateJpaVendorAdapter：

```java
@Bean
public JpaVendorAdapter jpaVendorAdapter() {
    HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter();
    // 有多个属性需要设置到厂商适配器上，但是最重要的是database属性
    adapter.setDatabase("HSQL");
    adapter.setShowSql(true);
    adapter.setGenerateDdl(false);
    adapter.setDatabasePlatform("org.hibernate.dialect.HSQLDialect");
    return adapter;
}
```

Hibernate的JPA适配器支持多种数据库，可以通过其database属性配置使用哪个数据库：

| 数据库平台           | 属性database的值 |
| -------------------- | ---------------- |
| IBM DB2              | DB2              |
| Apache Derby         | DERBY            |
| H2                   | H2               |
| Hypersonic           | HSQL             |
| Informix             | INFORMIX         |
| MySQL                | MYSQL            |
| Oracle               | ORACLE           |
| PostgresQL           | POSTGRESQL       |
| Microsoft SQL Server | SQLSERVER        |
| Sybase               | SYBASE           |

persistence.xml文件的主要作用就在于识别持久化单元中的实体类。但是从Spring 3.1开始，能够在LocalContainerEntityManagerFactoryBean中直接设置packagesToScan属性：

```java
@Bean
public LocalContainerEntityManagerFactoryBean entityManagerFactory(
    DataSource dataSource, JpaVendorAdapter jpaVendorAdapter) {
    LocalContainerEntityManagerFactoryBean emfb =
        new LocalContainerEntityManagerFactoryBean();
    emfb.setDataSource(dataSource);
    emfb.setJpaVendorAdapter(jpaVendorAdapter);
    // 在这个配置中，LocalContainerEntityManagerFactoryBean
    // 会扫描com.angus.spittr.domain包，查找带有@Entity注解的类
    emfb.setPackagesToScan("com.angus.spittr.domain");
    return emfb;
}
```

**从JNDI获取实体管理器工厂**



























