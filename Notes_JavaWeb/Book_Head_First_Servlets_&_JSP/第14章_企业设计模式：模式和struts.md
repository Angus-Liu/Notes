### # 业务委托

使用业务委托模式，Web层控制器就不用考虑应用的模型组件是否是远程的。

**业务委托特性：**

+ 相当于一个代理，实现了远程服务的接口；
+ 初始化与远程服务的通信；
+ 处理通信细节和异常；
+ 从控制器组件接收请求；
+ 转换请求，并转发到业务服务（通过桩）；
+ 转换响应，并返回给控制器组件；
+ 处理远程组件查找和通信的有关细节，使控制器更为内聚。

**业务委托原则：**

+ 业务委托建立在以下原则基础上：
  + 隐藏复杂性
  + 根据接口编写代码
  + 松耦合
  + 关注点分离
+ 尽可能减少业务层改变对Web层的影响；
+ 减少层间的耦合；
+ 向应用增加一层，这会增加复杂性；
+ 对业务委托的方法调用应当是粗粒度的，以减少网络流量。

### # 服务定位器

使用服务定位器来完成注册表查找，使其他要完成JNDI查找（或其他类型的注册表查找）的组件（如业务委托）得到简化。

**服务定位器特性：**

+ 得到InitialContext对象；
+ 完成注册表查找；
+ 处理通信细节和异常；
+ 通过缓存先前得到的引用，可以提高性能。
+ 可以用于多种类的注册表，如 JNDI、RMI、UDDI和COS命名。

**服务定位器原则：**

+ 服务定位器建立在以下原则基础上：
  + 隐藏复杂性
  + 关注点分离
+ 当远程组件改变位置或容器时，尽可能减少对Web层的影响；
+ 减少层间的耦合。

### # 传输对象

使用传输对象模式，通过提供粗粒度远程组件（通常是一个实体）的本地表示，尽量减少网络流量。

**传输对象功能：**

+ 提供远程实体（也就是说，维护一些数据状态的对象）的一个本地表示；
+ 尽量减少网络流量；
+ 可以遵循Java bean的约定，以便其他对象能轻松地访问；
+ 实现为一个可串行化的对象，从而能跨网络移动；
+ 通常视图组件能很容易地访问。

**传输对象原则：**

+ 传输对象建立在以下基本原则基础上：
  + 减少网络流量
+ 通过细粒度调用访问远程组件的数据时，利用传输对象能尽量减少对Web层性能的影响；
+ 减少层间的耦合；
+ 缺点是，访问传输对象的组件可能接收到过时的数据，因为传输对象的数据实际上表示在别处存储的状态；
+ 要让可更新的传输对象安全地实现并发，这通常很复杂。

### # 拦截过滤器

使用拦截过滤器模式来修改发送至servlet的请求，或者修改发送给用户的响应。

**拦截过滤器功能：**

+ 可以在请求到达servlet之前拦截/修改请求；
+ 在响应返回给客户之前可以拦截/修改响应；
+ 过滤器要使用DD以声明方式部署；
+ 过滤器是模块化的，因此可以串成链执行；
+ 过滤器的生命周期由容器管理；
+ 过滤器必须实现容器回调方法。

**拦截过滤器原则：**

+ 拦截过滤器建立在一下原则基础上：
  + 内聚
  + 松耦合
  + 增强声明式控制
+ 通过声明式控制，可以很容易地暂时或永久地是实现过滤器；
+ 利用声明式控制，可以很容易地更新调用顺序。

### # 模型视图控制器（MVC）

使用MVC模式来创建一个逻辑结构，将代码分离到应用的3中基本组件（模型、视图、控制器）。这会增加各组件的内聚度，并且得到更大的可重用性，特别是模型组件。

**MVC特性：**

+ 可以独立地修改视图，而不影响控制器和模型；
+ 模型组件对视图和控制器组件隐藏了内部细节（数据结构）；
+ 如果模型遵循一个严格的契约（接口），那么这些组件可以在其他应用领域重用，如GUI和J2ME。
+ 模型代码和控制器分离，这样可以更容易地移植为使用远程服务组件。

**MVC原则：**

+ MVC建立在以下原则基础上：
  + 关注点分离
  + 松耦合
+ 提高各组件的内聚度；
+ 增加应用的整体复杂性（确实如此，因为尽管各个组件之间变得更加内聚，但是MVC会向应用增加许多组件）
+ 