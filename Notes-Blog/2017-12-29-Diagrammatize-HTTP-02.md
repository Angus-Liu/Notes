---
title: 《图解HTTP》读书笔记
subtitle: 第02章 简单的HTTP协议
author: Angus Liu
cdn: header-off
date: 2017-12-29 20:09:02
header-img: https://i.loli.net/2017/12/29/5a4634c502b15.jpg
tags:
      - 《图解HTTP》
      - 读书笔记
      - HTTP
---
> 到一个新的地方旅行，必须有人带领，才能使自己也融入其中的风景。不管去过多少国家，绕了地球几圈，我们都很难体会地球到底有多大。不过，若能结识好友，眼前的风景就会变得广大而深奥。
> <p align="right"> —— 星野道夫《在漫长的路途中》 </p>

## 2.1 HTTP协议用于客户端之间
(1) HTTP协议和TCP/IP协议族内的其他众多协议相同，用于客户端和服务器之间的通信。
(2) 请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。
(3) 在两台计算机之间使用HTTP协议时，必定是一端担任客户端角色，另一端担任服务器端角色。有时候，按实际情况，两台计算机之间的角色可能互换。

## 2.2 通过请求和响应的交换达成通信
(1) HTTP协议规定，请求必先从客户端发出，最后服务器端响应请求并返回。
(2) 下面是一个具体的实例：
![84ab85e4-dd91-4fa6-9ebe-0bdb9764546e](https://i.loli.net/2017/12/29/5a46369702756.jpg)
&emsp;① 客户端发给某个HTTP服务器端的请求报文的内容中，起始行开头的GET表示请求访问服务器类型，称为方法（method）。随后的字符串/index.html指明了请求访问的资源对象，也叫做请求URI（request-URI）。最后的HTTP/1.1，即HTTP的版本号，用来提示客户端使用的HTTP协议功能。
![b8de7157-f8bf-4d7c-adf9-291079d61f33](https://i.loli.net/2017/12/29/5a4636bfa3442.jpg)
&emsp;② 综合来看，这段请求内容的意思是：请求访问某台HTTP服务器上的/Index.html页面资源。
&emsp;③ 请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。
![d87819c3-3bdc-4f66-b0dc-3391bee06339](https://i.loli.net/2017/12/29/5a46371b8f5a5.png)
&emsp;④ 接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。
![bfd1d664-6a97-40d8-8fb2-21808f189764](https://i.loli.net/2017/12/29/5a463743cf2ca.jpg)
&emsp;⑤ 在起始的行开头的HTTP/1.1表示服务器对应的HTTP版本。紧挨着的200 OK表示请求的处理结果的状态码（status code）和原因短语（reason-phrase）。下一行显示了创建响应的日期时间，是首部字段（header field）内的一个属性。接着以一空行分割，之后的内容称为资源实体的主体（entity body）。
&emsp;⑥ 响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。

## 2.3 HTTP是不保存状态的协议
(1) HTTP协议是一种不保存状态的协议，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。在HTTP这个级别，协议对于发送过的请求或者响应都不做持久化处理。
(2) 使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性。
(3) HTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态了。

## 2.4 请求URI定位资源
(1) HTTP协议使用URI定位互联网上的资源。
(2) 当客户端请求访问资源而发送请求时，URI需要作为请求报文中的请求URI包含在内。指定请求URI的方式有很多。
![b1231cfe-1fff-4fa6-86e6-13c595c35b57](https://i.loli.net/2017/12/29/5a4637bb0aa67.png)
(3) 如果不是访问特定资源而是对服务器本身发起请求，可以用一个*来代替请求URI。下面的例子是查询HTTP服务器支持的HTTP方法种类。
![6756f751-3ad1-4e52-8415-7655fb8d2d0d](https://i.loli.net/2017/12/29/5a4637ee83fd2.png)

## 2.5 告知服务器意图的HTTP方法
(1) **GET：获取资源**
GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果是文本，那就保持原样返回；如果是像CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。
![3b423b232-fe4c-4b0f-83df-db32977ec39](https://i.loli.net/2017/12/29/5a4639160cb07.jpg)
![12e2b6ed-e47b-425f-9ef4-c751d5bc3a90](https://i.loli.net/2017/12/29/5a4638399c585.jpg)
(2) **POST：传输实体主体**
POST方法用来传输实体的主体。虽然GET方法也可以用来传输实体的主体，但一般不采用GET方法进行传输，而是用POST方法。虽说POST的功能和GET很相似，但POST的主要目的并不是获取响应的主体内容。
![d9c045c5-44de-427c-a990-276bd5c66fbf](https://i.loli.net/2017/12/29/5a463988695e4.jpg)
(3) **PUT：传输文件**
PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存请求URI指定的位置。但是，鉴于HTTP/1.1上的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST（REpresentational State Transfer，表征状态转移）标准的同类Web网站，就可能会开放使用PUT方法。
![dd4ee0fe-ef8e-4829-8caa-56bde4d16684](https://i.loli.net/2017/12/29/5a4639bd09aa1.png)
(4) **HEAD：获得报文首部**
HEAD方法和GET方法一样，只是不返回报文主体内容。用于确认URI的有效性及资源更新的日期时间等。
![3b423bc0-fe4c-4b0f-83df-db32977ec39f](https://i.loli.net/2017/12/29/5a46382841c4f.jpg)
![d9432a1a-a9da-4050-b2b6-3fba4a302e83](https://i.loli.net/2017/12/29/5a4639e569ae9.jpg)
(5) **DELETE：删除文件**
DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。但是，HTTP/1.1的DELETE方法本身也不带验证机制，所以一般的Web网站也不会使用。
![8d7b2314-1953-428a-86ae-43d4e236e8ac](https://i.loli.net/2017/12/29/5a463a1fce0e4.jpg)
(6) **OPTIONS：询问支持的方法**
OPTIONS方法用来查询针对请求URI指定的资源支持的方法。
![d7167fc0-05a6-4016-80c0-40a6aa905142](https://i.loli.net/2017/12/29/5a463a528a5d2.jpg)
![c18462fa-e605-4eea-b3a5-520a029ecfe7](https://i.loli.net/2017/12/29/5a463a6f01b72.png)
(7) **TRACE：追踪路径**
TRACE方法是让Web服务器将之前的请求通信环回给客户端的方法。发送请求时，在Max-Forwards首部字段中填入数据，每经过一个服务器端就将该数字减1，当数值刚好减为0时，就停止传输，最后接收到请求的服务器则返回状态码200 OK的相应。客户端通过TRACE方法可以查询发出去的请求是怎样被加工修改/篡改的。这是因为，请求想要连接到的目标服务器可能通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作。TRACE方法不常用，并且它容易引发XST（Cross-Site Tracing，跨站追踪）攻击。
![ace999d5-2a29-48f7-bf44-7bad41675491](https://i.loli.net/2017/12/30/5a4731d55deee.png)
(8) **CONNECT：要求用隧道协议连接代理**
CONNECT方法要求在于代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接字）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。CONNECT方法的格式如下：
![5b3c4059-624a-441d-a3c2-ced256e921d2](https://i.loli.net/2017/12/29/5a463adf239b7.jpg)

## 2.6 使用方法下达命令
(1) 向请求URI指定的资源发送请求报文时。采用称为方法的命令。
(2) 方法的作用在于，可以指定请求的资源按期望产生某种行为。方法中有GET、POST、HEAD等。
![b58896f9-b5c1-4493-b75e-4a0ea430cf46](https://i.loli.net/2017/12/29/5a463b1041a60.png)
![998b1959-cb72-4952-9c26-4ac08b0aae50](https://i.loli.net/2017/12/29/5a463b1beec14.png)

## 2.7 持久连接节省通信量
HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接，增加了很多不必要的通信开销。
### 2.7.1 持久连接
(1) 为解决上述问题，HTTP/1.1和一部分HTTP/1.0想出了持久连接（HTTP Persistent Connections，也称为HTTP keep-alive或HTTP Connection reuse）的方法。
(2) 持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。
(3) 持久连接的好处在于减少了TCP连接的重复建立和断开造成的额外开销，减轻了服务器的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早地结束。
(4) 在HTTP/1.1中，所有的连接默认都是持久连接，但在HTTP/1.0中并未标准化。
### 2.7.2 管线化
(1) 持久化使得多数请求以管线化（pipelining）方式发送称为可能。
(2) 与以前发送请求需等待并收到响应后才能发送下一个请求相比，管线化可以不用等待响应即可直接发送下一个请求。

## 2.8 使用Cookie的状态管理
(1) HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理，也就无法根据之前的状态进行本次的请求处理。
(2) 无状态协议的优点是简单，可以减少服务器的CPU即内存资源的消耗。
(3) 为了保留无状态协议的特征的同时解决出现的矛盾。引入了Cookie技术。Cookie技术通过在请求和响应的报文中写入Cookie信息来控制客户端的状态。
(4) Cookie会根据从服务器发送的响应报文内的一个叫Set-Cookie的首部字段信息，通知客户端保存Cookie。当客户端下次再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。
(5) 服务器端发现客户端发送过来的Cookie之后，会检查是哪一个客户端发来的连接请求，并对比服务上的记录，得到之前的状态信息。
(6) 发生Cookie交互时。HTTP请求报文和响应报文的内容如下：
![d172f0f9-5999-40e2-b079-82cc37573738](https://i.loli.net/2017/12/29/5a463b82bc97a.png)
