### # MySQL 支持的索引

1. B-tree 索引

   + B-tree 索引的特点
     + B-tree 索引以 B+ 树的结构存储数据
     + B-tree 索引能够加快数据的查询速度
     + B-tree 索引更适合进行范围查找

   + 在什么情况下可以用到 B-tree 索引
     + 全值匹配的查询，例：order_sn = '78675645645645'
     + 匹配最左前缀的查询，例：匹配联合索引的最左列的数据
     + 匹配列前缀查询，例：order_sn like '9876%'
     + 匹配范围值的查询，例：order_sn > '12345' and order_sn < '98765'
     + 精确匹配左前列并范围匹配另外一列
     + 只访问索引的查询

    + B-tree 的使用限制
      + 如果不是按照索引最左列开始查找，则无法使用索引
      + 使用索引时不能跳过索引中的列
      + Not in 和 \<\>（不等于，!=）操作无法使用索引
      + 如果查询中某个列的范围查询，则其右边所有列都无法使用索引

2. Hash 索引

    + Hash 索引的特点
      + Hash 索引是基于 Hash 表实现的，只有查询条件精确匹配 Hash 索引的所有列时，才能够使用到 Hash 索引
      + 对于 Hash 索引中的所有列，存储引擎都会为每一行计算一个 Hash 码，Hash 索引中存储的就是 Hash 码
    + Hash 索引的限制
      + Hash 索引必须进行二次查找
      + Hash 索引无法用于排序
      + Hash 索引不支持部分索引查找也不支持范围查找
      + Hash 索引中的 Hash 码的计算有可能存在 Hash 冲突

### # 为什么要使用索引

1. 索引大大减少了存储引擎需要扫描的数据量
2. 索引可以帮助我们进行排序以避免使用临时表
3. 索引可以把随机 I/O 变为顺序 I/O

### # 索引是不是越多越好

1. 索引会增写操作的成本
2. 太多的索引会增加查询优化器的选择时间

### # 索引优化策略

1. 索引列上不能使用表达式或函数
2. 前缀索引和索引列的选择性
   + 针对列数据过长，但要注意前缀的重复性
3. 联合索引
   + 如何选择索引列的顺序
     + 经常会被使用的列优先
     + 选择性高的列优先
     + 宽度小的列优先
4. 覆盖索引
   + 优点
     + 可以优化缓存，减少磁盘 IO 操作
     + 可以减少随机 IO，变随机 IO 操作为顺序 IO 操作
     + 可以避免 Innodb 主键索引的二次查询
     + 可以避免 MyISAM 表进行系统调用
   + 无法使用覆盖索引的情况
     + 存储引擎不支持覆盖索引
     + 查询中使用了太多的列
     + 使用了双 % 号的 like 查询

### # 使用索引来优化查询

1. 使用索引扫描来优化排序
   + 通过排序操作，按照索引顺序扫描数据
   + 索引的列顺序和 Order by 子句的顺序完全一致
   + 索引中所有列的方向（升序，降序）和 Order by 子句完全一致
   + Order by 中的字段全部在关联表中第一张表中
2. 模拟 Hash 索引优化查询（在表中添加一列存储该列数据的 Hash 值）
   + 只能处理键值的全值匹配查找
   + 所使用的 Hash 函数决定着索引键的大小
3. 利用索引优化锁
   + 索引可以减少锁定的行数
   + 索引可以加快处理速度，同时也加快了锁的释放






















