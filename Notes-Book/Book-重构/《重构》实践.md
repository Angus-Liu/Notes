# 《重构》在真实项目中的实践（一）

最近主要在学习掘金小册《MySQL 是怎样运行的》，断断续续看了很久，很多地方百思不得其解（实际上是看了就忘），整个人快要自闭。想了想还是先做点自己能做的事缓一缓吧，于是便有了这篇文章。《重构》这本书在年前就已经看了一遍，但是很多知识点只是过了一下，没有去实践。年后的开发工作不算紧张，故而开发之余会有一些时间去思考项目代码的优化，本系列文章便是记录《重构》一书中所提到的各项技巧在团队真实项目（以 Kotlin 作为编程语言的 Web 后台项目）中的实践，计划按照《重构》每一章所讲，依据自身实践出一篇文章。因涉及到公司机密，例子中所举代码并非真实项目代码，希望大家能理解。

美国童子军有这样一条规则：“Leave the campground cleaner than you found it”（离开前让营地比你到来时更干净），重构的目的亦在于此。Martin Fowler 在书中这样解释“重构”：“在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。重构是一种经千锤百炼形成的有条不紊的程序整理方法，可以最大限度地减少整理过程中引入错误的几率。本质上说，重构就是在代码写好之后改进它的设计”。

注意，这一句重点在于“在代码写好之后改进它的设计”，不是说颠倒黑白，先编码后设计，而是告诉大家，应该让设计贯穿代码的整个构筑过程。哪怕你不是当初打地基的人，现在给你一栋危楼，通过重构，你依然有机会将其改造成海景洋房。也许，最重要的不是掌握了什么方法，而是你有没有开始。

既然“鼓吹 ”大家去重构，那必然是有很多好处的：

- 重构能帮助你理解项目：相信大家都不是项目最初的设计者和编写者，
- 重构能避免你无端背锅：明明是调用的一个很久版本的函数，为什么会被测试测出问题
- 重构提升你的设计能力：受够了产品不断提出的需求，每次修改轻辄复制粘贴，重辄伤筋动骨
- 重构改进软件设计
- 重构使软件更容易理解
- 重构帮助找到 bug
- 重构提高编程速度

在开始重构之前，我们先来捋一捋代码的哪些征兆告诉我们项目应该开始重构了：

- 重复代码：代码复制短期看节省了开发时间，但长期必然会加剧维护的难度。DRY（Don't repeat yourself）和 Rule of three（三次原则）告诉我们，相同的代码出现两次时无关紧要，但出现第三次时就应该开始重构了。
- 过长函数：古代道家哲学就告诉我们“大道至简”，对于一个函数或是类来说，同样如此。我们不希望别人读自己写的函数到一半就已经不知道函数第一行的目的是什么了。虽然注释能帮助我们读懂代码，但请注意，注释不是除臭剂。
- 过度设计的超类：

优秀软件设计的最终目的都是奔着“高内聚低耦合”去的

并没有说函数多长才算长，不过可以以函数的职责多样性来判断。



下一篇文章将会依据“第 6章 重新组织函数”进行编写，敬请期待



## 第6章 重新组织函数

### 6.1 Extract Method（提炼函数）

动机：一个过长的函数或者一段需要注释才能让人理解用途的代码，应该放进一个独立函数中。简短而命名良好的函数，易读，易复用，易测试，易重构。

方法：将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。

实践：

## 第7章 在对象之间搬移特性

### 7.1 Move Method（搬移函数）

动机：如果一个类有太多行为，或与另一个类有太多合作而形成高度耦合，就可以进行搬移函数操作。这样可以使系统中的类更简单，也将更干净利落地实现系统交付的任务。

方法：在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯 的委托函数，或是将旧函数完全移除。

实践：

## 第8章 重新组织数据

### 8.15 Replace Type Code with State/Strategy （以 State/Strategy 取代类型码）

动机：

方法：



## 第9章 简化条件表达式

### 9.6 Replace Conditional with Polymorphism （以多态取代条件表达式）

动机：

方法：

实践：策略模式在代码中的运用



## 第10章 简化函数调用

### 10.12 Replace Constructor with Factory Method （以工厂函数取代构造函数）

动机：对象间的转换基本不传达编码逻辑，但是会降低代码清晰度，影响阅读。此外，这部分代码，因为没有复用，也会导致重复代码。该建议同样出现在《Effective Java》一书第一节，其重要程度可想而知。

方法：



## 第11章 处理概括关系

### 11.2 Pull Up Method（函数上移）

动机：如果某个函数在各子类中的函数体都相同，很可能这就是代码复制导致的，此时应通过函数上移避免行为重复。

方法：在超类中新建一个与子类相同的函数，或者将已有抽象函数实现为与子类相同的逻辑，移除子类对该函数的实现。

实践：

- 将异常类型状态码的 getCode、getMsg、errorString 方法上移至 PicbookError 中，在需要特别对待的地方再进行重写

## 其他（自我总结）

### 1.异常下移 & 方法返回值属性区分

动机：很多时候调用方希望方法返回值是不为null，但因为方法返回值可为空，所以每一个调用处都做了不为空(!!)或者抛异常处理。导致大量重复操作，且代码不易读。

方法：将不为空处理（既!!）或者抛异常移至被调用方法中，被调用方法编写者有义务保证返回值不为空，避免调用方重复判断。若方法返回值可空，且有同名的非空方法，此时无法通过返回值进行重载，则该返回值可空方法名应用Nullable修饰（如：fun getNullableUserByName(name: String): User? {...}），明确告知调用方，需要其对null进行处理。



对于kotlin是异常下移，对于java则是消除受检异常



### 3.实体类字段应尽量声明非空类型，必要时给出默认值。以val修饰，对查询开放，对修改封闭，保证其不可变性。



### 3.代码分层

- Dao
- Service
- Manager
- Controller



4.工具类用 Object 修饰



5.实体类用 data class 修饰，对于 Java，个人比较推崇使用 lombok 注解，因为没有什么是比代码清晰更重要的



6.map{it.resourceId to it}.toMap => associatedBy{} associated 类方法完全可以解决我们的各种集合转map需求







不再用的代码。且没有第三方调用，直接删掉，有GIT在，不用怕



通过扩展方法，我们可以省略很多代码 fun Collection.avgBy{}



写在最后：要学会这些技巧非常简单，只需把《重构》所讲每一章节，对照自己的项目进行改进，你就会发现有很多可以改进的地方。我真的推荐大家看一看《重构》这本书，对你好，对我好，对他也好。



代码精进的道路路途遥远，不仅仅需要的是知识和技巧，还包括实际项目中经验的积累，目前的我也暂时只能到这了



“重构”的技巧除了从书本中获取，更多的是需要经验的积累。目前的我经验尚浅，还不足以写出更深层次的文章。因而这将会是一个持续更新的系列，我将持续输出自己对“重构”的理解和实践，多谢大家的支持。





公众号名称：我们都是爱码士、走码观花、一码平川



其实一开始选择“重构”这个主题来写文章，自己心里还是很虚的，毕竟要真正掌握“重构”是需要大量的项目经验的。但自己还是抱着“初生牛犊不怕虎”的心态，把自己的从书和实际项目中的经验结合起来，希望能够总结出一些经验方法来。