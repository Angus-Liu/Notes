下一篇文章将会依据“第 6章 重新组织函数”进行编写，敬请期待



## 第6章 重新组织函数

### 6.1 Extract Method（提炼函数）

动机：一个过长的函数或者一段需要注释才能让人理解用途的代码，应该放进一个独立函数中。简短而命名良好的函数，易读，易复用，易测试，易重构。

方法：将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。

实践：

## 第7章 在对象之间搬移特性

### 7.1 Move Method（搬移函数）

动机：如果一个类有太多行为，或与另一个类有太多合作而形成高度耦合，就可以进行搬移函数操作。这样可以使系统中的类更简单，也将更干净利落地实现系统交付的任务。

方法：在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯 的委托函数，或是将旧函数完全移除。

实践：

## 第8章 重新组织数据

### 8.15 Replace Type Code with State/Strategy （以 State/Strategy 取代类型码）

动机：

方法：



## 第9章 简化条件表达式

### 9.6 Replace Conditional with Polymorphism （以多态取代条件表达式）

动机：

方法：

实践：策略模式在代码中的运用



## 第10章 简化函数调用

### 10.12 Replace Constructor with Factory Method （以工厂函数取代构造函数）

动机：对象间的转换基本不传达编码逻辑，但是会降低代码清晰度，影响阅读。此外，这部分代码，因为没有复用，也会导致重复代码。该建议同样出现在《Effective Java》一书第一节，其重要程度可想而知。

方法：



## 第11章 处理概括关系

### 11.2 Pull Up Method（函数上移）

动机：如果某个函数在各子类中的函数体都相同，很可能这就是代码复制导致的，此时应通过函数上移避免行为重复。

方法：在超类中新建一个与子类相同的函数，或者将已有抽象函数实现为与子类相同的逻辑，移除子类对该函数的实现。

实践：

- 将异常类型状态码的 getCode、getMsg、errorString 方法上移至 PicbookError 中，在需要特别对待的地方再进行重写

## 其他（自我总结）

### 1.异常下移 & 方法返回值属性区分

动机：很多时候调用方希望方法返回值是不为null，但因为方法返回值可为空，所以每一个调用处都做了不为空(!!)或者抛异常处理。导致大量重复操作，且代码不易读。

方法：将不为空处理（既!!）或者抛异常移至被调用方法中，被调用方法编写者有义务保证返回值不为空，避免调用方重复判断。若方法返回值可空，且有同名的非空方法，此时无法通过返回值进行重载，则该返回值可空方法名应用Nullable修饰（如：fun getNullableUserByName(name: String): User? {...}），明确告知调用方，需要其对null进行处理。



对于kotlin是异常下移，对于java则是消除受检异常



### 3.实体类字段应尽量声明非空类型，必要时给出默认值。以val修饰，对查询开放，对修改封闭，保证其不可变性。



### 3.代码分层

- Dao
- Service
- Manager
- Controller



4.工具类用 Object 修饰



5.实体类用 data class 修饰，对于 Java，个人比较推崇使用 lombok 注解，因为没有什么是比代码清晰更重要的



6.map{it.resourceId to it}.toMap => associatedBy{} associated 类方法完全可以解决我们的各种集合转map需求







不再用的代码。且没有第三方调用，直接删掉，有GIT在，不用怕



通过扩展方法，我们可以省略很多代码 fun Collection.avgBy{}