### # 内存中字的存储

CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元来存放，这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。

字单元：即存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。我们将起始地址为N的字单元简称为N地址字单元。任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可看做是一个字单元。

### # DS和[address]

8086CPU中有一个DS（数据段寄存器）寄存器，通常用来存放要访问的数据的段地址。比如我们要读取10000H单元的内容：

```assembly
mov bx,1000H
mov ds,bx
mov al,[0]
```

上面的三条指令将10000H（1000:0）的数据读到al中。

8086CPU不支持将数据直接送入段寄存器的操作（硬件设计的问题），ds是一个段寄存器，所以只能用一个寄存器进行中转。

### # mov、add、sub指令

mov指令可以有以下几种格式：

```assembly
mov 寄存器，数据            比如：mov ax,8
mov 寄存器，寄存器          比如：mov ax,bx
mov 寄存器，内存单元        比如：mov ax,[0]
mov 内存单元，寄存器        比如：mov [0],ax
mov 内存单元，段寄存器      比如：mov [0],ds
mov 段寄存器，内存单元      比如：mov ds,[0]
mov 段寄存器，寄存器        比如：mov ds,ax
mov 寄存器，段寄存器        比如：mov ax,ds
```

add和sub指令一样，都有两个操作对象。它们也可以有以下几种形式： 

```assembly
add 寄存器，数据            比如：add ax,8
add 寄存器，寄存器          比如：add ax,bx
add 寄存器，内存单元        比如：add ax,[0]
add 内存单元，寄存器        比如：add [0],ax

sub 寄存器，数据            比如：sub ax,9
sub 寄存器，寄存器          比如：sub ax,bx
sub 寄存器，内存单元        比如：sub ax,[0]
sub 内存单元，寄存器        比如：sub [0],ax
```

### # 数据段

对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。可以将一组长度为N（N≤64KB）、地址连续、起始地址为16的倍数的内存单元当做专门存储数据的内存空间，从而定义了一个数据段。比如用123B0H-123B9H这段内存空间来存放数据，我们可以认为其就是一个数据段，段地址为123BH，长度为10个字节。

如何访问数据段中的数据呢？将一段内存当作数据段，是我们在编程时的一种安排，可以在具体操作的时候，用ds存放数据段的段地址，再根据需要，用相关的指令访问数据段中的具体单元。

### # 小结

(1) 字在内存中存储时，要用两个地址的内存单元来存放，字的低位字节存放在低字节单元中，高位字节存放在高地址单元中。

(2) 用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。

(3) [address]表示一个偏移地址为address的内存单元。

(4) 在内存和寄存器中传送字型数据时，高地址单元和高8位寄存器，低地址单元和低8位寄存器相对应。

(5) mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。

(6) 可以根据自己的推测，在Debug中实验指令的新格式。

### # CPU提供的栈机制

8086CPU提供入栈和出栈指令，最基本的两个是PUSH（入栈）和POP（出栈）。比如，push ax表示将寄存器ax的内容送入栈中，pop ax表示从栈顶取出数据送入ax。8086CPU的入栈和出栈操作都是以字为单位进行的。

8086CPU中，有两个和寄存器，堆栈段寄存器SS和堆栈指针寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。任意时刻，SS：SP指向栈顶元素。push指令和pop指令执行是，CPU从SS和SP中得到栈顶的地址。

push ax的执行，由以下两步完成：

(1) SP = SP - 2，SS：SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；（栈下方为高地址）

(2) 将ax的内容送入到SS：SP指向的内存单元处，SS：SP此时指向新栈顶。

8086CPU中，入栈时，栈顶从高地址向低地址方向增长。

pop ax的执行过程和push ax刚好相反，由以下两步完成：

(1) 将SS：SP指向的内存单元处的数据送入到ax中；

(2) SP = SP + 2,SS：SP指向当前栈顶下面的数据，以当前栈顶下面的单元作为新的栈顶。

出栈后，pop操作前的数据依然存在，但是，它已不再栈中。当再次执行push等入栈指令后，它将被覆盖。

### # 栈顶越界问题

8086CPU不保证我们对栈的操作不会越界，它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。

我们自己编程时要小心栈顶越界问题，要根据可能用到的最大栈控件，来安排栈的大小，防止数据过多而导致栈顶越界；执行出栈操作时也要注意，以防止栈空的时候继续出栈而导致越界。

### # push、pop指令

push和pop指令的格式可以是如下形式：

```assembly
push 寄存器        ；将一个寄存器中的数据入栈
pop  寄存器        ；出栈，用一个寄存器接收出栈的数据
```

当然也可以是如下形式： 

```assembly
push 段寄存器      ；将一个段寄存器中的数据入栈
pop  段寄存器      ；出栈，用一个段寄存器接收出栈的数据
```

push和pop也可以在内存单元和内存单元之间传送数据： 

```ass
push 内存单元      ；将一个内存字单元出的字入栈（注意，栈操作都是以字为单位的）
pop  内存单元      ；出栈，用一个内存单元接收出栈的数据
```

