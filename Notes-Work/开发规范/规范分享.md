## Java 开发规范分享

### # 《阿里巴巴 Java 开发手册》

IDEA 插件：Alibaba Java Coding Guidelines

####  变量命名

> There are only two hard things in Computer Science: cache invalidation and naming things.
>
> -- Phil Karlton

- https://unbug.github.io/codelf/
- IDEA 插件：Translation

#### 命名风格

- 【强制】常量命名全部大写，单词间用下划线隔开。
- 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。 
- 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。 

#### 代码格式

- 【推荐】IDEA 格式化快捷键：Ctrl + Alt + L

#### OOP归约

- 【推荐】IDEA 插件：Lombok

- 【强制】所有的 POJO 类属性必须使用包装数据类型。 

- 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。 

- 【强制】 Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。

  > 正例： "test".equals(object);
  > 反例： object.equals("test");
  > 说明： 推荐使用 java.util.Objects#equals（JDK7 引入的工具类） 

- 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。 

#### 集合处理

- 【强制】只要重写 equals，就必须重写 hashCode。
- 【推荐】 集合初始化时， 指定集合初始值大小，减少集合的扩容操作 。initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loader factor） 默认为 0.75， 如果暂时无法确定初始值大小，请设置为 16（即默认值）
- 【参考】 利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历、对比、 去重操作 

#### 控制语句

- 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止； 在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使空代码。 

  > 处理默认情况；使语义更清晰

- 【推荐】超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下： 

  ```java
  public void today() {
      if (isBusy()) {
          System.out.println(“change time.”);
          return;
      }
      if (isFree()) {
          System.out.println(“go to travel.”);
          return;
      }
      System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”);
      return;
  }
  
  // 多层嵌套
  if (true){
      if (true){
          if (true){
              for (){
                  if (true){
                      // 业务代码
                  }
              }
          }
      }
  }
  // 卫语句
  if (false){
      return;  
  }
  if (false){
      return;  
  }
  if (false){
      return;  
  }
  for (){
      if (false){
          continue;
      }
      // 业务代码
  }
  ```

- 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。 

  ```java
  // 正例
  final boolean existed = (file.open(fileName, "w") != null) && (...) || (...);
  if (existed) {
      ...
  }
  // 反例：
  if ((file.open(fileName, "w") != null) && (...) || (...)) {
      ...
  }
  ```

#### 注释归约

- 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/\*\*内容\*/格式，不得使用 // xxx 方式。 

  说明： 在 IDE 编辑窗口中， Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释； 在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。 
  
- 【强制】所有的抽象方法（包括接口中的方法） 必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。

- 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释，注意与代码对齐。  

### #《Thinking in Java》

#### 枚举类型

- 【参考】通过枚举类型实现表驱动代码

  ```java
  public enum OptEnum {
      // 每个 enum 实例实现抽象方法，执行不同的逻辑
      ADD {
          @Override
          int operation(int a, int b) {
              return a + b;
          }
      },
      MINUS {
          @Override
          int operation(int a, int b) {
              return a - b;
          }
      },
      MULTIPLY {
          @Override
          int operation(int a, int b) {
              return a * b;
          }
      },
      DIVIDE {
          @Override
          int operation(int a, int b) {
              return a / b;
          }
      },
      ;
  
      // 定义一个抽象方法
      abstract int operation(int a, int b);
  }
  
  public class Condition {
      public static void main(String[] args) {
          printRes(OptEnum.ADD, 1, 2);
          printRes(OptEnum.MINUS, 1, 2);
          printRes(OptEnum.MULTIPLY, 1, 2);
          printRes(OptEnum.DIVIDE, 1, 2);
      }
  
      public static void printRes(OptEnum optEnum, int a, int b) {
          System.out.println(optEnum.operation(a, b));
      }
  }
  
  ```

### #《Effective Java》

- 【推荐】考虑用静态工厂方法代替构造函数

  - 静态工厂方法相比于构造器的第一个优点是，它们具有名称。 如果构造器的参数本身没有描述返回的对象，那么具有适当名称的静态工厂会更易于使用，客户端生成的代码也更易于阅读。例如，构造器 BigInteger(int, int, Random) 返回的 BigInteger 可能为素数，它可以更好地用一个名为 BigInteger.probablePrime 的静态工厂方法来表示。（此方法是在 Java 1.4 中添加的。） 

  - 静态工厂方法相比于构造器的第二个优点是，不需要在每次被调用时都创建一个新对象。 这允许不可变类使用预先构建的实例，或者缓存构造好的实例，进行重复分配，以避免创建不必要的重复对象。Boolean.valueOf(boolean) 方法就说明了这种技术：它从来不会创建对象。这种技术类似于享元模式（flyweight pattern）。如果经常请求相同的对象，特别是它们的创建成本较高，则这种方法可以极大地提高性能。 

    ```java
    public static Boolean valueOf(boolean b) {
        return b ? Boolean.TRUE : Boolean.FALSE;
    }
    ```

  - 静态工厂方法相比于构造器的第三个优点是，它们可以返回原返回类型的任何子类型的对象。** 这使得你在选择返回对象的类时具有很大的灵活性。 

  - 静态工厂方法的第四个优点是，其作为输入参数的函数，返回对象的类可以随着调用而变化。 只要是已声明返回类型的子类型都是允许的。返回对象的类也可能因发行版本不同而有差异。 

  - 静态工厂方法的第五个优点是，当编写包含该静态工厂方法的类时，返回对象所属的实现类不需要存在。 这种灵活的静态工厂方法构成了服务提供者框架（service provider framework）的基础，如 Java 数据库连接 API（JDBC）。服务提供者框架是多个服务提供者实现一个服务的系统，该系统为客户端提供多个适用的实现，并将客户端与实现解耦。

  

- 【推荐】使用 try-with-resources 语句替代 try-finally 语句

  ```java
  // 当使用多个资源时，try-finally 就变得臃肿不堪！
  static void copy(String src, String dst) throws IOException {
      InputStream in = new FileInputStream(src);
      try {
          OutputStream out = new FileOutputStream(dst);
          try {
              byte[] buf = new byte[BUFFER_SIZE];
              int n;
              while ((n = in.read(buf)) >= 0)
                  out.write(buf, 0, n);
          } finally {
              out.close();
          }
      }
      finally {
          in.close();
      }
  }
  
  // try-with-resources 处理多个资源简短且友好！
  static void copy(String src, String dst) throws IOException {
      try (InputStream   in = new FileInputStream(src);
          OutputStream out = new FileOutputStream(dst)) {
          byte[] buf = new byte[BUFFER_SIZE];
          int n;
          while ((n = in.read(buf)) >= 0)
              out.write(buf, 0, n);
      }
  }
  ```

  

### #《重构》

### #《代码大全》