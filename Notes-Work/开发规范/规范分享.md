## Java 开发规范分享

### # 《阿里巴巴 Java 开发手册》

IDEA 插件：Alibaba Java Coding Guidelines

####  变量命名

> There are only two hard things in Computer Science: cache invalidation and naming things.
>
> -- Phil Karlton

- CODEIF：https://unbug.github.io/codelf/
- IDEA 插件：Translation（Ctrl + Command + O）

#### 命名风格

- 【强制】除国际通用的名字外，代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。

  正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式 也要避免采用。

  > 反例: DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3 
  >
  > 正例: alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。 

- 【强制】 类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：(领域模型的相关命名)DO / BO / DTO / VO等。

- 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。

- 【强制】常量命名全部大写，单词间用下划线隔开。

- 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。 

- 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。 

- 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。

  说明:枚举其实就是特殊的常量类，且构造方法被默认强制是私有。

  > 正例:枚举名字:DealStatusEnum，成员名称:SUCCESS / UNKOWN_REASON。

- 【参考】各层命名规约:

  - Service/DAO层方法命名规约 

    1) 获取单个对象的方法用get做前缀。

    2) 获取多个对象的方法用list做前缀。

    3) 获取统计值的方法用count做前缀。

    4) 插入的方法用save(推荐)或insert做前缀。 

    5) 删除的方法用remove(推荐)或delete做前缀。 

    6) 修改的方法用update做前缀。 

  - 领域模型命名规约

    1) 数据对象:xxxDO，xxx即为数据表名。

    2) 数据传输对象:xxxDTO，xxx为业务领域相关的名称。

    3) 展示对象:xxxVO，xxx一般为网页名称。

    4) POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。 

#### 格式规约

- 【推荐】IDEA 格式化快捷键：Ctrl + Alt + L（Command + Option + L）
- 【强制】IDE的text file encoding设置为UTF-8；IDE中文件的换行符使用Unix格式，
  不要使用 windows 格式。

#### OOP归约

- 【推荐】IDEA 插件：Lombok

- 【强制】接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。

- 【强制】 Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。

  说明： 推荐使用 java.util.Objects#equals（JDK7 引入的工具类） 

  > 正例： "test".equals(object);
  > 反例： object.equals("test");

- 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。 

- 【强制】所有的 POJO 类属性必须使用包装数据类型。 

- 【推荐】所有的局部变量使用基本数据类型。

  > 正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。
  >
  > 反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示:0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。 

- 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。 

#### 集合处理

- 【强制】只要重写 equals，就必须重写 hashCode。

  说明：相等的对象必须具有相等的散列码。因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。如果自定义对象做为Map的键，那么必须重写hashCode和equals。（hashCode相同，equals是否一定为true）

- 【推荐】 集合初始化时， 指定集合初始值大小，减少集合的扩容操作 。initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loader factor） 默认为 0.75， 如果暂时无法确定初始值大小，请设置为 16（即默认值）

- 【参考】 利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历、对比、 去重操作 

#### 控制语句

- 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止； 在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使空代码。 

  > 处理默认情况；使语义更完整清晰。

- 【推荐】超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下： 

  ```java
  // 多层嵌套
  if (true){
      if (true){
          if (true){
              for (){
                  if (true){
                      // 业务代码
                  }
              }
          }
      }
  }
  // 卫语句
  if (false){
      return;  
  }
  if (false){
      return;  
  }
  if (false){
      return;  
  }
  for (){
      if (false){
          continue;
      }
      // 业务代码
  }
  ```
  
- 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。 

  ```java
  // 正例
  final boolean existed = (file.open(fileName, "w") != null) && (...) || (...);
  if (existed) {
      ...
  }
  // 反例：
  if ((file.open(fileName, "w") != null) && (...) || (...)) {
      ...
  }
  ```

- 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、 

  获取数据库连接，进行不必要的 try-catch 操作(这个 try-catch 是否可以移至循环体外)。 

#### 注释归约

- 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/\*\*内容\*/格式，不得使用 // xxx 方式。 

  说明： 在 IDE 编辑窗口中， Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释； 在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。 （IDEA：Ctrl + Q）
  
- 【强制】所有的抽象方法（包括接口中的方法） 必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。

- 【强制】所有的类都必须添加创建者信息。 

- 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描， 经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。 

  - 待办事宜（TODO）：（标记人，标记时间，[预计处理时间]） 表示需要实现，但目前还未实现的功能。
  - 错误，不能工作（FIXME）：（标记人，标记时间，[预计处理时间]）在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。 

#### 异常处理

- 【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。
- 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的 内容。  

### #《Effective Java》

- 【推荐】考虑用静态工厂方法代替构造函数

  - 静态工厂方法相比于构造函数的第一个优点是，它们具有名称。 如果构造器的参数本身没有描述返回的对象，那么具有适当名称的静态工厂会更易于使用，客户端生成的代码也更易于阅读。例如，构造器 BigInteger(int, int, Random) 返回的 BigInteger 可能为素数，它可以更好地用一个名为 BigInteger.probablePrime 的静态工厂方法来表示。（此方法是在 Java 1.4 中添加的。） 

  - 静态工厂方法相比于构造函数的第二个优点是，不需要在每次被调用时都创建一个新对象。 这允许不可变类使用预先构建的实例，或者缓存构造好的实例，进行重复分配，以避免创建不必要的重复对象。Boolean.valueOf(boolean) 方法就说明了这种技术：它从来不会创建对象。这种技术类似于享元模式（flyweight pattern）。如果经常请求相同的对象，特别是它们的创建成本较高，则这种方法可以极大地提高性能。 

    ```java
    public static Boolean valueOf(boolean b) {
        return b ? Boolean.TRUE : Boolean.FALSE;
    }
    ```

  - 静态工厂方法相比于构造函数的第三个优点是，它们可以返回原返回类型的任何子类型的对象。这使得你在选择返回对象的类时具有很大的灵活性。 

  - 静态工厂方法的第四个优点是，其作为输入参数的函数，返回对象的类可以随着调用而变化。 只要是已声明返回类型的子类型都是允许的。

  - 静态工厂方法的第五个优点是，当编写包含该静态工厂方法的类时，返回对象所属的实现类不需要存在。 这种灵活的静态工厂方法构成了服务提供者框架（service provider framework）的基础，如 Java 数据库连接 API（JDBC）。服务提供者框架是多个服务提供者实现一个服务的系统，该系统为客户端提供多个适用的实现，并将客户端与实现解耦。

  - 以下是静态工厂方法的一些常用命名。当然，这份清单远非详尽：

    - **from** —— 一种类型转换方法（type-conversion method），它接收单个参数并返回此类型的相应实例，例如：

      ```java
      Date d = Date.from(instant);
      ```

    - **of** —— 一种聚合方法（aggregation method），它接受多个参数，返回包含这些参数的该类型的实例，例如： 

      ```java
      Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
      ```

    - **valueOf** —— 较 `from` 和 `of` 更为详细的可选方案，例如： 

      ```java
      BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
      ```

    - **instance 或 getInstance** —— 返回由其参数（如果有）描述的实例，但不能说实例与参数具有相同的值，例如： 

      ```java
      StackWalker luke = StackWalker.getInstance(options);
      ```

    - **create 或 newInstance** —— 同 `instance` 或 `getInstance` 相似，但该方法需要保证每次调用时都返回一个新的实例，例如： 

      ```java
      Object newArray = Array.newInstance(classObject, arrayLen);
      ```

    - **get*Type*** —— 同 `getInstance` 相似，但它是在工厂方法位于不同的类中时才使用。*Type* 表示该工厂方法返回的对象类型，例如： 

      ```java
      FileStore fs = Files.getFileStore(path);
      ```

    - **new*Type*** —— 同 `newInstance` 相似，但它是在工厂方法位于不同的类中时才使用。*Type* 表示该工厂方法返回的对象类型，例如：

      ```java
      BufferedReader br = Files.newBufferedReader(path);
      ```

    - **type** —— `getType` 和 `newType` 的简洁替代，例如：

      ```java
      List<Complaint> litany = Collections.list(legacyLitany);  
      ```

- 【推荐】当构造方法参数过多时使用 builder 模式

  静态工厂和构造方法都有一个限制：它们不能很好地扩展到很多可选参数的情景。请考虑一个代表包装食品上的营养成分标签的例子。这些标签有几个必需的属性——每次建议的摄入量，每罐的份量和每份卡路里 ，以及超过 20 个可选的属性——总脂肪、饱和脂肪、反式脂肪、胆固醇、钠等等。大多数产品只有这些可选字段中的少数，且具有非零值。
  传统上，程序员使用了可伸缩（telescoping constructor）构造方法模式，在这种模式中，提供了一个只有所需参数的构造函数，另一个只有一个可选参数，第三个有两个可选参数，等等，最终在构造函数中包含所有可选参数。这就是它在实践中的样子。为了简便起见，只显示了四个可选属性：

  ```java
  public class NutritionFacts {
    private final int servingSize;  // (mL)            required
    private final int servings;     // (per container) required
    private final int calories;     // (per serving)   optional
    private final int fat;          // (g/serving)     optional
    private final int sodium;       // (mg/serving)    optional
    private final int carbohydrate; // (g/serving)     optional
  
    public NutritionFacts(int servingSize, int servings) {
      this(servingSize, servings, 0);
    }
  
    public NutritionFacts(int servingSize, int servings,
                          int calories) {
      this(servingSize, servings, calories, 0);
    }
  
    public NutritionFacts(int servingSize, int servings,
                          int calories, int fat) {
      this(servingSize, servings, calories, fat, 0);
    }
  
    public NutritionFacts(int servingSize, int servings,
                          int calories, int fat, int sodium) {
      this(servingSize, servings, calories, fat, sodium, 0);
    }
  
    public NutritionFacts(int servingSize, int servings,
                          int calories, int fat, int sodium, int carbohydrate) {
      this.servingSize  = servingSize;
      this.servings     = servings;
      this.calories     = calories;
      this.fat          = fat;
      this.sodium       = sodium;
      this.carbohydrate = carbohydrate;
    }
  }
  
  NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27);
  ```

  可伸缩构造方法模式是有效的，但是当有很多参数时，很难编写客户端代码，而且很难读懂它。当在构造方法中遇到许多可选参数时，另一种选择是 JavaBeans 模式，在这种模式中，调用一个无参数的构造函数来创建对象，然后调用 `setter` 方法来设置每个必需的参数和可选参数：

  ```java
  public class NutritionFacts {
    // Parameters initialized to default values (if any)
    private int servingSize  = -1; // Required; no default value
    private int servings     = -1; // Required; no default value
    private int calories     = 0;
    private int fat          = 0;
    private int sodium       = 0;
    private int carbohydrate = 0;
  
    public NutritionFacts() { }
  
    // Setters
    public void setServingSize(int val)  { servingSize = val; }
    public void setServings(int val)    { servings = val; }
    public void setCalories(int val)    { calories = val; }
    public void setFat(int val)         { fat = val; }
    public void setSodium(int val)      { sodium = val; }
    public void setCarbohydrate(int val) { carbohydrate = val; }
  }
  
  NutritionFacts cocaCola = new NutritionFacts();
  cocaCola.setServingSize(240);
  cocaCola.setServings(8);
  cocaCola.setCalories(100);
  cocaCola.setSodium(35);
  cocaCola.setCarbohydrate(27);
  ```

  JavaBeans 模式排除了让类不可变的可能性，并且需要在程序员的部分增加工作以确保线程安全。

  还有第三种选择，它结合了可伸缩构造方法模式的安全性和 JavaBean 模式的可读性。 它是 Builder 模式的一种形式。客户端不直接调用所需的对象，而是调用构造方法 (或静态工厂)，并使用所有必需的参数，并获得一个 builder 对象。然后，客户端调用 builder 对象的 setter 相似方法来设置每个可选参数。最后，客户端调用一个无参的 build 方法来生成对象，该对象通常是不可变的。Builder 通常是它所构建的类的一个静态成员类。以下是它在实践中的示例：

  ```java
  public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;
  
    public static class Builder {
      // Required parameters
      private final int servingSize;
      private final int servings;
  
      // Optional parameters - initialized to default values
      private int calories      = 0;
      private int fat           = 0;
      private int sodium        = 0;
      private int carbohydrate  = 0;
  
      public Builder(int servingSize, int servings) {
        this.servingSize = servingSize;
        this.servings    = servings;
      }
  
      public Builder calories(int val) { 
        calories = val;      
        return this;
      }
  
      public Builder fat(int val) { 
        fat = val;           
        return this;
      }
  
      public Builder sodium(int val) { 
        sodium = val;        
        return this; 
      }
  
      public Builder carbohydrate(int val) { 
        carbohydrate = val;  
        return this; 
      }
  
      public NutritionFacts build() {
        return new NutritionFacts(this);
      }
    }
  
    private NutritionFacts(Builder builder) {
      servingSize  = builder.servingSize;
      servings     = builder.servings;
      calories     = builder.calories;
      fat          = builder.fat;
      sodium       = builder.sodium;
      carbohydrate = builder.carbohydrate;
    }
  }
  
  NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)
    .calories(100)
    .sodium(35)
    .carbohydrate(27)
    .build();
  ```

- 【推荐】使用 try-with-resources 语句替代 try-finally 语句

  ```java
  // 当使用多个资源时，try-finally 就变得臃肿不堪！
  static void copy(String src, String dst) throws IOException {
      InputStream in = new FileInputStream(src);
      try {
          OutputStream out = new FileOutputStream(dst);
          try {
              byte[] buf = new byte[BUFFER_SIZE];
              int n;
              while ((n = in.read(buf)) >= 0)
                  out.write(buf, 0, n);
          } finally {
              out.close();
          }
      }
      finally {
          in.close();
      }
  }
  
  // try-with-resources 处理多个资源简短且友好！
  static void copy(String src, String dst) throws IOException {
      try (InputStream   in = new FileInputStream(src);
          OutputStream out = new FileOutputStream(dst)) {
          byte[] buf = new byte[BUFFER_SIZE];
          int n;
          while ((n = in.read(buf)) >= 0)
              out.write(buf, 0, n);
      }
  }
  ```

- 【推荐】优先考虑泛型

  ```java
  public class Result {
    int code;
    String msg;
    Object data;
    private Result(Integer code, String msg, Object data) {
      this.code = code;
      this.msg = msg;
      this.data = data;
    }
    public static Result success(Object data) {
      return new Result(200,"ok", data);
    }
  }
  
  @PostMapping("/user/{id}")
  public Result getUser(Integer id) {
    // ...
    User user = ...
    return Result.success(user);
  }
  
  public class Result<T> {
    int code;
    String msg;
    T data;
    // getter & setter
    private Result(Integer code, String msg, T data) {
      this.code = code;
      this.msg = msg;
      this.data = data;
    }
    public static <T> Result<T> success(T data) {
      return new Result<>(200,"ok", data);
    }
  }
  
  @PostMapping("/user/{id}")
  public Result<User> getUser(Integer id) {
    // ...
    User user = ...
    return Result.success(user);
  }
  ```

- 【推荐】使用枚举类型替代整型常量

  枚举更具可读性，更安全，更强大。 许多枚举不需要显式构造方法或成员，但其他人则可以通过将数据与每个常量关联并提供行为受此数据影响的方法而受益。 使用单一方法关联多个行为可以减少枚举。 在这种相对罕见的情况下，更喜欢使用常量特定的方法来枚举自己的值。

  ```java
  // 没有提供类型安全的方式，也没有提供任何表达力。 如果你将一个 Apple 传递给一个需要 Orange 的方法，编译器不会出现警告。
  // 没有简单的方法将 int 枚举常量转换为可打印的字符串。 
  public static final int APPLE_FUJI         = 0;
  public static final int APPLE_PIPPIN       = 1;
  public static final int APPLE_GRANNY_SMITH = 2;
  
  public static final int ORANGE_NAVEL  = 0;
  public static final int ORANGE_TEMPLE = 1;
  public static final int ORANGE_BLOOD  = 2;。
  
  // Java 提供了一种避免 int 和 String 枚举模式的所有缺点的替代方法
  public enum Apple  { FUJI, PIPPIN, GRANNY_SMITH }
  public enum Orange { NAVEL, TEMPLE, BLOOD }
  
  // 特定于常量的方法实现可以与特定于常量的数据结合使用(通过枚举类型实现表驱动代码)。
  public enum Operation {
    PLUS("+") {
      @Override 
      public double apply(double x, double y) { return x + y; }
    },
    MINUS("-") {
      @Override 
      public double apply(double x, double y) { return x - y; }
    },
    TIMES("*") {
      @Override 
      public double apply(double x, double y) { return x * y; }
    },
    DIVIDE("/") {
      @Override 
      public double apply(double x, double y) { return x / y; }
    };
  
    private final String symbol;
  
    Operation(String symbol) { this.symbol = symbol; }
  
    @Override 
    public String toString() { return symbol; }
  
    public abstract double apply(double x, double y);
  }
  
  public static void main(String[] args) {
      double x = Double.parseDouble(args[0]);
      double y = Double.parseDouble(args[1]);
      for (Operation op : Operation.values())
          System.out.printf("%f %s %f = %f%n",
                            x, op, y, op.apply(x, y));
  }
  
  // 2.000000 + 4.000000 = 6.000000
  // 2.000000 - 4.000000 = -2.000000
  // 2.000000 * 4.000000 = 8.000000
  // 2.000000 / 4.000000 = 0.500000
  ```

- 【推荐】为所有已公开的 API 元素编写文档注释

  ```java
  /**
   * A college degree, such as B.S., {@literal M.S.} or Ph.D.
   *
   * @author Angus
   * @date 2019-07-31
   */
  public class Degree { ... }
  
  /**
   * Returns the element at the specified position in this list.
   *
   * <p>This method is <i>not</i> guaranteed to run in constant
   * time. In some implementations it may run in time proportional
   * to the element position.
   *
   * @param  index index of element to return; must be
   *         non-negative and less than the size of this list
   * @return the element at the specified position in this list
   * @throws IndexOutOfBoundsException if the index is out of range
   *         ({@code index < 0 || index >= this.size()})
   */
  E get(int index);
  
  /**
   * An object that maps keys to values.  A map cannot contain
   * duplicate keys; each key can map to at most one value.
   *
   * (Remainder omitted)
   *
   * @param <K> the type of keys maintained by this map
   * @param <V> the type of mapped values
   */
  public interface Map<K, V> { ... }
  
  /**
   * An instrument section of a symphony orchestra.
   */
  public enum OrchestraSection {
      /** Woodwinds, such as flute, clarinet, and oboe. */
      WOODWIND,
  
      /** Brass instruments, such as french horn and trumpet. */
      BRASS,
  
      /** Percussion instruments, such as timpani and cymbals. */
      PERCUSSION,
  
      /** Stringed instruments, such as violin and cello. */
      STRING;
  }
  
  /**
   * Indicates that the annotated method is a test method that
   * must throw the designated exception to pass.
   */
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.METHOD)
  public @interface ExceptionTest {
       /**
        * The exception that the annotated test method must throw
        * in order to pass. (The test is permitted to throw any
        * subtype of the type described by this class object.)
        */
      Class<? extends Throwable> value();
  }
  ```

- 【推荐】若需要精确答案就应避免使用 float 和 double 类型

  float 和 double 类型主要用于科学计算和工程计算。它们执行二进制浮点运算，该算法经过精心设计，能够在很大范围内快速提供精确的近似值。但是，它们不能提供准确的结果，也不应该在需要精确结果的地方使用。**float 和 double 类型特别不适合进行货币计算**，因为不可能将 0.1（或 10 的任意负次幂）精确地表示为 float 或 double。

  ```java
  System.out.println(1.03 - 0.42); // 0.6100000000000001
  ```

  解决这个问题的正确方法是 **使用 BigDecimal、int 或 long 进行货币计算。**

  ```java
  System.out.println((103 - 42) / 100.0);
  ```

- 【推荐】通过接口使用对象

  如果你养成了使用接口作为类型的习惯，那么你的程序将更加灵活。如果没有合适的接口，就使用类层次结构中提供所需功能的最底层的类。

  ```java
  // Good - uses interface as type
  Set<Son> sonSet = new LinkedHashSet<>();
  // Bad - uses class as type!
  LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
  // 如果你决定要切换实现，只需在构造函数中更改类名（或使用不同的静态工厂）。例如，第一个声明可以改为：
  Set<Son> sonSet = new HashSet<>();
  ```



**书籍推荐：《Effective Java》、《Thinking in Java》、《重构》、《代码大全》**

